# Стандарт. Картарский язык программирования. Версия 0.1. [Черновик]

## Оглавление.

[0. Введение.](#0)

[1. Общие принципы.](#1)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[1.1. Пример кода.](#1.1)

[](#){name=0}
## 0. Введение.

[](#){name=1}
## 1. Общие принципы.

[](#){name=1.1}
### 1.1. Пример кода.

Вот пример простейшей программы, которая выводит на экран сообщение "Привет, мир!".

~~~~
стат метод Запустить() Целое:
	Кар.Печатать("Привет, мир!\н")
	вернуть 0
~~~~
Данный текст программы должен быть записан в кодировке UTF-8 и помещен в файл с раширением "кар", например: ПриветМир.кар. Далее его можно откомпилировать с помощью программы

~~~~
kar ПриветМир -o hello.exe
~~~~

и запустить из командной строки

~~~~
hello.exe
~~~~

После запуска программа выведен на экран строку "Привет, мир!".

### 1.2. Общее описание языка.

Язык программирования Картарика или Картарский язык является строго-типизированным объектно-ориентированным языком с обязательной инициализацией переменных с ограниченным сборщиком мусора и запретом кольцевых зависимостей.

(??? Дать ссылку на раздел, описывающий запрет кольцевых зависимостей.)

#### 1.2.4. Внешние ссылки.

Если в одном модуле необходима ссылка на другой модуль, то он записывается в виде пути и имени файла (без расширения), разделенных точкой. В настоящее время модулем может быть модуль из стандартной библиотеки. Например, если модуль с именем `Модуль.кар` лежит в каталоге `Каталог1`, который в свою очередь лежит в каталоге `Каталог2`, то путь к модулю записывается так: `Каталог2.Каталог1.Модуль`.

Алгоритм поиска модуля. При поиске модуля программа пытается найти модуль в текущем каталоге, затем в каталоге проекта, затем в каталоге библиотек, затем в каталоге стандартной библиотеки.

В сообщениях об ошибках или в других случаях, когда нужно однозначно описать какой конкретно модуль имеется в виду можно написать:

~~~~
Стандарт:Модуль.Подмодуль
Библиотека.<ИмяБиблиотеки>.<ВерсияБиблиотеки>:Модуль.Подмодуль
Проект:Модуль.Подмодуль
~~~~

### 1.3. Общая структура проекта.

Файловая структура проекта. Проект состоит из одного модуля. Результатом компиляции модуля является исполняемая программа.

В модулях записывается непосредственно код программы.

В картарском языке модуль = файл = класс.

Файл модуля имеет расширение кар. Имя файла (без расширения) должен соответствовать правилам токена (см. ???).

Подробное описание синтаксиса модулей смотри в ???.

### 1.4. Юникод и кодировка.

Написанные программы используют ЮНИКОД версии 14.0 (UNICODE 14.0) , описание которого можно найти на сайте

[http://www.unicode.org](http://www.unicode.org)

Используемая кодировка: UTF-8. Соответствующий стандарт находится здесь:

[https://tools.ietf.org/rfc/rfc3629.txt](https://tools.ietf.org/rfc/rfc3629.txt)

## 2. Лексическая структура модуля.

### 2.1. Грамматика.

(???) Это относится скорее ко второй главе. Лексическая структура модуля.

Для описания грамматики используется расширенная форма Бэкуса-Наура, с некоторыми дополнениями.

Описание отдельных символов:

* Переменная, состоящая из одного символа, обозначает этот символ. Например: ф - русская буква ф, z - латинская буква z и т.д.
* Для различения похожих букв русского и английского алфавита, там где не понятен контекст, перед русской буквой ставится префикс р (русский), перед английской буквой ставится префикс l (latin). Например ра обозначает русскую букву а, la - обозначает латинскую букву a.
* Переменной "юникод" обозначается любой символ Юникода.
* Переменной "буква" обозначается любая буква любого алфавита Юникода.
* Символ Юникода также можно записать в виде \uHEX. То есть значала записывается обратная косая черта, затем английская буква u и после неё номер символа в таблицце Юникода в шестнадцатеричном формате. Например \u5F обозначает символ нижнего подчеркивания.

Правила записи расширенной формы Бэкуса-Наура, используемые в этом документе:

* Конкатенация. Конкатенируемые символы заключены в двойные кавычки. Правило вида A = "BCD". обозначает, что нетерминал A состоит из трех символов — B, C и D.
* Выбор. Обозначается вертикальной чертой. Правило вида A = B|C|D. Обозначает, что нетерминал A может состоять либо из B, либо из C, либо из D.
* Для сокращения записи выбора, если символы стоят рядом в таблице Юникод, можно обозначить промежуток символом тире. Правило вида 1-3. Обозначает либо 1, либо 2, либо 3.
* Кроме. Исключения в выборе обозначается восклицаетльным знаком. Правило 0-9!3!5 обозначает все цифры от 0 до 9, кроме 3 и 5. То есть 0, 1, 2, 4, 6, 7, 8, 9.
* Условное вхождение. Квадратные скобки выделяют необязательный элемент выражения, который может присутствовать, а может и отсутствовать. Правило вида A = [B]. обозначает, что нетерминал A либо является пустым, либо состоит из символа B.
* Повторение. Фигурные скобки обозначают конкатенацию любого числа (включая нуль) записанных в ней элементов. Правило вида A = {B}. обозначает, что A — либо пустой, либо представляет собой конкатенацию любого числа символов B (то есть A — это либо пустой элемент, либо B, либо BB, либо BBB и так далее). Если требуется, чтобы A представлял собой либо B, либо произвольное число B, но не мог быть пустым, используется запись A = B{B}.
* Круглые скобки. Они применяются для группировки элементов при формировании сложных выражений. Например, правило A = (B|C)(D|E). обозначает, что A состоит из двух символов, первым из которых является либо B, либо C, вторым — либо D, либо E, то есть A может быть одной из цепочек BD, BE, CD, CE.

### 2.1. Конец строки.

Грамматическое описание конца строки:

~~~~
КонецСтроки = (\u0A)|(\u0D \u0A)
~~~~

Конец строки может быть либо символов перевода строки либо сочетанием символов возврата каретки и перевода строки (\n или \r\n в обозначении языков с С-подобным синтаксисом).

### 2.2. Комментарии.

Комментарии могут быть однострочными и многострочными.

Грамматическое описание однострочного комментария:

~~~~
ОднострочныйКомментарий = "//" {Юникод!КонецСтроки}
~~~~

Перед началом однострочного комментария ставится удвоенный символ "/" послечего идёт любая последовательность символов до символов конца строки.

Грамматическое описание многострочного комментария:

~~~~
Многострочный комментарий = "/*" {Юникод!"*/"} "*/"
~~~~

Многострочный комментарий заключен в символы "`/*`" и "`*/`" внутри которого может быть любая комбинация текстовых символов за исключением последовательности "*/".

Комментарий можно поставить в любое место, где можно поставить пробельный символ.

### 2.3. Пробелы.

Грамматическое описание пробельных символов:
~~~~
ПробельныйСимвол = \u20 | \u09 | Комментарий
Пробел = ПробельныйСимвол{ПробельныйСимвол}
~~~~

Пробел состоит из одного или более пробельных символов. Пробельным символом является символ пробела или символ горизонтальной табуляции.

В начале строки Пробел выполняет также дополнительную функцию определения к какому блоку принадлежит строка. Один символ горизонтальной табуляции является табуляцией длиной в четыре пробела, комментарий - пробельный сисмвол длиной в ноль пробелов.
(??? Возможно нужен отдельный раздел для описания блоков.)

### 2.4. Ключевые слова.

(??? добавить список ключевых слов из последующих глав: числа, поля, пусто, модификаторы полей и методов, модификаторы для класса и т.д. и т.п.)

~~~~
КлючевоеСлово = "Целое8" | "Целое16" | "Целое32" ... ( и т.д.)
~~~~

### 2.5. Идентификаторы.

Грамматическое описание идентификатора:

(??? грамматическое описание для разных алфавитов.)

~~~~
Буква = А-Я | а-я | A-Z | a-z | _
Цифра = 0-9
Идентификатор = (Буква{Буква | Цифра})!КлючевоеСлово
~~~~

Идентификатор - это набор букв и цифр неограниченной длины, начинающийся с буквы. Набор букв и цифр не должен совпадать с ключевыми словами.

В одном идентификаторе нельзя одновременно использовать символы из разных алфавитов.

### 2.6. Литералы.

#### 2.6.1. Целые числа.

Грамматическое описание:

~~~~
Цифра = 0-9
Знак = + | -
ЦелоеЧисло = [Знак] Цифра{Цифра}
~~~~

Вначале целого числа может стоять знак "+" или "-". Далее идет набор цифр от 0 до 9.

#### 2.6.2. Цифра в шестнадцатиричном формате.

Грамматическое описание:

~~~~
ШестнадцатиричнаяЦифра = 0-9 | А | Б | В | Г | Д | Е
ШестнадцатиричноеЧисло = "0ш" ШестнадцатиричнаяЦифра{ШестнадцатиричнаяЦифра}
~~~~

Шестнадцатиричное число начинается с символов 0ш а затем идут одна или несколько шестнадцатиричных цифр: от нуля до девяти и далее A=10, Б=11, В=12, Г=13, Д=14, Е=15. Буквы могут быть как заглавные, так и маленькие.

??? Выглядит трешово, конечно. Другие варианты обсуждаемы. Вообще нужны ли шестнадцатиричные цифры? И как насчет двоичных и восмиричных чисел? Нужен ли знак перед началом числа?

#### 2.6.3. Числа с плавающей точкой.

Грамматическое описание:

~~~~
НеЧисло = "НеЧисло"

ПлюсБесконечность = "Бесконечность" | "ПлюсБесконечность"
МинусБесконечность = "МинусБесконечность"

Цифра = 0-9
Точка = \u2E
Знак = + | -
ОбычнаяЗаписьДробного = [Знак] Цифра{Цифра} Точка Цифра{Цифра}

Экспонента = "с" | "С"
ЭкспоненциальнаяЗаписьДробного = (ЦелоеЧисло | ОбычнаяЗаписьДробного) Экспонента ЦелоеЧисло

ДробноеЧисло = НеЧисло | ПлюсБесконечность | МинусБесконечность | ОбычнаяЗаписьДробного | ЭкспоненциальнаяЗаписьДробного
~~~~

Существует два основных типа записи чисел с плавающей точкой: обычная запись и экспоненциальная запись.

В обычной записи числа с плавающей точкой в начале может стоять знак "+" или "-". Далее идет набор цифр от 0 до 9, обозначающий целую часть числа, затем символ ".", затем цифры от 0 до 9, обозначающие дробную часть числа.

В экспоненциальной записи сначала идет мантисса, которая записывается как обычная запись числа, затем символ "с" или "С" разделяющее мантиссу и экспоненту, затем целое число, обозначающее экспоненту.

Кроме того, для особых значений чисел с плавающей точкой применяются ключевые слова "НеЧисло", "Бесконечность", "ПлюсБесконечность" и "МинусБесконечность".

Примечание. Знак, разделяющий мантиссу и экспоненту взяли "с" вместо "э", так как символ "э" находится скраю клавиатуры, поэтому "с" будет удобнее для набора. Под "с" имеется в виду слово "степень".

#### 2.6.4. Булевы значения.

Грамматическое описание:

~~~~
БулевоЗначение = "Да" | "Нет"
~~~~

Булево значение может принимать одно из двух значений "Да" или "Нет", соответствующие булевым значениям "Правда" и "Ложь" соответственно.

#### 2.6.5. Строковые литералы.

Грамматическое описание:

~~~~
ДвойныеКавычки = \u22
СимволИсключения = \u5C
СтрочныйСимвол = Юникод!ДвойныеКавычки!СимволИсключения
Строка = ДвойныеКавычки {СтрочныйСимвол | ИсключающиеСимволы} ДвойныеКавычки
~~~~

Двойные кавычки используются для обозначения строкового литерала. Внутри могут стоять любые символы кроме символа двойной кавычки и символа исключения. Символ исключения используется для создания исключающих символов, описанных в (??? ссылка на следующий пункт.)

#### 2.6.6. Исключающие символы для строковых литералов.

Грамматическое описание:

~~~~
СимволИсключения = \u5C
СимволВозвратаКаретки = СимволИсключения к
СимволНовойСтроки = СимволИсключения н
СимволГоризонтальнойТабуляции = СимволИсключения т
СимволДвойныхКавычек = СимволИсключения ДвойныеКавычки
СимволОбратногоСлеша = СимволИсключения СимволИсключения
ИсключающиеСимволы = СимволНовойСтроки | СимволГоризонтальнойТабуляции | СимволДвойныхКавычек | СимволОбратногоСлеша
~~~~

В строке можно записать сивол новой строки или сивол табуляции, напрямую написав их внутри строки или добавив сочетание сиволов "\н" или "\т" соответственно. Если необходимо добавить двойные кавычки внутри строки, необходимо добавить в строку сочетание "\"". Для добавления обратного слеша, необходимо просто его удвоить: "\\".

Также можно добавить юникод-символы, записав их шестнадцатиричные коды с помощью исключающего символа "\ш". Сначала пишется ключевое буквосочетание "\ш", затем пишутся шестнадцатиричный код символа. Можно написать сразу несколько кодов, для этого их надо писать через запятую. По окончании записи юникод-символов ставится пробел, либо любой другой символ, не использующийся в написании шестнадцатиричного символа. Если в конце шестнадцатиричных символов ставится пробел, то он съедается.

Пример:

~~~~
"Маленькая греческая буква альфа \ш3Б1"
"Маленькие греческие буквы альфа и бетта \ш3Б1,3Б2  22"
~~~~

Конечное преобразование этих строк будет таким:

~~~~
"Маленькая греческая буква альфа α"
"Маленькие греческие буквы альфа и бетта αβ 22"
~~~~

Обратите внимание, что в конце второй строки перед символами "22" два пробела. Первый из них обозначает конец исключающего символа "\ш" и как бы "съедается". Второй пробел остаётся.

#### 2.6.7. разделители.

Грамматическое описание:

~~~~
ОткрывающаясяСкобка = \u28
ЗакрывающаясяСкобка = \u29
Запятая = \u2C
~~~~

#### 2.6.8. операторы.

Следующие токены являются операторами:

~~~~
!"№;%:?*() ., -_=+\/*

Плюс = \u2B
Минус = \u2D
Умножить = \u2A
Разделить = \u2F
Остаток = \u25
Присвоение = \u3D
Точка = \u2E
Двоеточие= \u3A
Неопределённость = \u3F
Определенность = \u21

ПобитовоеИ = "би"
ПобитовоеИЛИ = "били"
ПобитовоеИсключающееИЛИ = "билине"
ПобитовоеНЕ = "бне"
ПобитовыйСдвигВправо = "вправо"
ПобитовыйСдвигВлево = "влево"

Равно = "=="
НеРавно = "!="
Больше = "больше"
Меньше = "меньше"
БольшеИлиРавно = "бир"
МеньшеИлиРавно = "мир"

ЛогическоеИ = "и"
ЛогическоеИЛИ = "или"
ЛогическоеНЕ = "не"
~~~~

### 2.7. Входные элементы и токены.

??? Здесь должно быть общее синтаксическое описание всего модуля.

## 3. Логическая структура модуля.

### 3.1. Строки модуля.

Фактически модуль разбивается на строки. Понятие строки модуля и строки текстового файла близки, но всё же различаются.

Разница состоит в следующем. В текстовом файле разделение на строки всегда происходит с помощью символа новой строки (). При разбиении модуля на строки, символ новой строки может игнорироваться в двух случаях:

1. Если символ новой строки находится в комментарии, он игнорируется при разбиении модуля на строки.

2. Внутри круглых скобок символ новой строки также игнорируется.

Поэтому существует 2 способа разбить строку модуля на несколько строк текстового файла:

1 способ. Комментарий сильнее символа новой строки. Это означает, что в любом месте, где разрешен пробельный символ можно с помощью комментария разделить одну строку на две. Например:

~~~~
поле Количество = /*

*/ 5
~~~~

2 способ. Скобки сильнее символа новой строки. Это означает, что внутри любой круглой скобки, везде, где разрешен пробельный символ можно добавить символ новой строки:

~~~~
стат метод ПосчитатьСумму(
    Целое Слагаемое1,
    Целое Слагаемое2
) Целое:
~~~~

### 3.2. Пустые строки модуля.

После раделения модуля на строки, пустые строки игнорируются. Пустые строки это строки модуля, которые состоят только из пробельных символов (то есть символов пробела, табуляции и комментариев).

### 3.3. Корневые элементы.

На более высоком уровне модуль делится на корневые элементы. Корневой элемент может либо состоять из одной строки модуля, либо из множевства строк. Если корневой элемент состоит из множества строк модуля, то он имеет блоковую структуру. Описание блоковой структуры смотри в пункте (??? ссылка).

Также для описания корневых элементов необходимо ввести понятие (арифметического) выражения и алгоритма. Арифметические выражения описаны в главе (??? ссылка). Алгоритм описан в главе (??? ссылка).

Корневые элементы могут быть разными по структуре и иметь различную функциональность. Более подробно все корневые элементы описаны в главе (??? ссылка).

### 3.4. Блоки.

Блок состоит из более чем одной строки, блоки могут быть вложенные. Общая лексическая структура такова:

~~~~
<Отступ блока верхнего уровня><Описание блока>:
<Отступ блока верхнего уровня><Отступ блока><Строка модуля>
<Отступ блока верхнего уровня><Отступ блока><Строка модуля>
...
<Отступ блока верхнего уровня><Отступ блока><Строка модуля>
~~~~

Так как блоки могут быть вложенными, то при описании блока каждая его строка должна начинаться с отступа блока более вержнего уровня. В первой строке идёт описание блока, заканчивающееся двоеточием. Последующие строки модуля внутри блока называются телом блока. Тело блока состоит из строк модуля в каждом из которые поставлены одинаковые отступы и затем после отступов написаны строки модуля.

Отступы состоят из пробелов и табуляций. Один символ табуляции эквивалентен 4 символам пробела. Отступ блока может состоять из любого ненулевого количества пробелов. У корневых блоков модуля отступ равен 0 символов. У блоков более нижнего уровня отступ всегда больше чем у блоков верхнего уровня.

Любая строка модуля в свою очередь также может быть блоком, со своим описанием и телом блока, но уже с большим отступом, чем родительский блок. После окончания блока идут строковые описания блока верхнего уровня с отступами блока верхнего уровня.

Существует также вырожденный случай, когда блок может быть пустым. В этом случае он оформляется следующим образом:

~~~~
<Отступ блока верхнего уровня><Описание блока>:
<Отступ блока верхнего уровня><Отступ блока>пропустить
~~~~

То есть тело блока должно состоять из одной непустой строки модуля, с ключевым словом "пропустить".

### 3.5. Пример.

Пример программы:

~~~~
стат метод Запустить() Целое:
	конст КоличествоПараметров = 3
                          // Пустая строка. Здесь может быть сколько угодно пробелов и комментов.
	если (Параметры.Длина не равно КоличествоПараметров):
		Ат.Печатать("Количество параметров программы должно быть равно 3.%н")

~~~~

В данном примере первая строка описывает блок "метод" с именем запустить. Внутри блока метода находится строковое выражение, описывающее константу, пустая строка и далее вложенный блок "если".

## 4. Типы данных.

Картарский язык программирования - это строго типизированный язык. Это означает, что каждая переменная и выражение имеет свой тип, известный на этапе компиляции.

### 4.1. Простые типы данных

Простые типы данных делятся на беззнаковые целые, знаковые целые, числа с плавающей точкой, булевы выражения и перечисления.

#### 4.1.1. Целые числа.

Ряд типов для знаковых целых чисел:

* Целое8 - 8-ми битное знаковое целое число. Принимает целочисленные значения от -128 до 127 включительно.
* Целое16 - 16-ти битное знаковое целое число. Принимает целочисленные значения от -32768 до 32767 включительно.
* Целое32 - 32-ти битное знаковое целое число. Принимает целочисленные значения от -2147483648 до 2147483647 включительно.
* Целое64 - 64-ти битное знаковое целое число. Принимает целочисленные значения от -9223372036854775808 до 9223372036854775807 включительно.
* Целое - синоним для типа Целое32.

Ряд типов для беззнаковых целых чисел:

* Счётное8 - 8-ми битное беззнаковое целое число. Принимает целочисленные значения от 0 до 255 включительно.
* Счётное16 - 16-ми битное беззнаковое целое число. Принимает целочисленные значения от 0 до 65535 включительно.
* Счётное32 - 32-ми битное беззнаковое целое число. Принимает целочисленные значения от 0 до 4294967295 включительно.
* Счётное64 - 64-ми битное беззнаковое целое число. Принимает целочисленные значения от 0 до 18446744073709551615 включительно.
* Счётное - синоним для типа Счётное32.

#### 4.1.2. Числа с плавающей запятой.

Ряд типов для чисел с плавающей запятой:

* Дробное32 - числа с плавающей точкой одинарной точности (single precision) согласно стандарту IEEE Standard for Binary Floating-Point Arithmetic, ANSI/IEEE Standard 754-1985 (IEEE, New York).
* Дробное64 - числа с плавающей точкой двойной точности (double precision) согласно стандарту IEEE Standard for Binary Floating-Point Arithmetic, ANSI/IEEE Standard 754-1985 (IEEE, New York).
* Дробное - синоним для типа Дробное64.

#### 4.1.3. Булевый тип.

Булевый тип:

* Буль - булево число, принимающее одно из двух значений: "Да" или "Нет".

### 4.2. Ссылочные типы данных

#### 4.2.1. Строка.

Экземпляр класса "Строка" представляет набор символов Юникод. Строковый объект имеет константное (неизменяемое) значение. Строковые литералы ссылаются на экземпляры класса "Строка".

#### 4.2.2. Неопределенность.

Неопределенность - это тип данных, который модифицирует основной тип данных. Тип неопределенность может принимать либо специальное значение "Пусто", либо значение основного типа.

~~~~
поле Количество = Целое?(Пусто)
поле Цена = Целое?(35)
~~~~

Перевод из неопределенного типа в соответствующий ему определенный можно совершить с помощью вызова метода "или" (??? ссылка) или с помощью блока "раскрыть" (??? ссылка). Пример:

~~~~
поле Количество = Целое?(Пусто)

Кар.Напечатать(Количество.или(-1))

раскрыть Количество как Кол:
    Кар.Напечатать(Кол)
иначе:
    Кар.Напечатать("Количество не определено")
~~~~

(???) В примере блок "раскрыть" проверить на корректность написания.

## 5. Выражения.

### 5.1. Простейшее выражение.

Простейшим выражением является переменная либо константа.

Грамматическое описание:

~~~~
Выражение = Идентификатор | ЦелоеЧисло | ШестнадцатиричноеЧисло | ДробноеЧисло | БулевоЗначение | Строка
~~~~

Примеры простейшего выражения:

~~~~
Кар
3
3.5
Нет
"Привет, мир!!!"
~~~~



### 5.2. Преобразование простых типов.

Все преобразования являются явными. Неявные преобразования запрещены.

Общий вид методов преобразования из типа Тип1 в тип Тип2 имеют один из следующих видов:

~~~~
открытый стат метод Тип2(Тип1 значение) Тип2
открытый стат метод Тип2(Тип1 значение) Тип2?
~~~~

Эта группа методов преобразует один простейший тип в другой. Возвращаемым значением может быть либо выходной тип, либо неопределенность выходного типа. Неопределенность появляется в преобразованиях между теми типами, которые не всегда могут быть однозначно преобразованы.

Пример преобразования типа Целое в тип Целое8:

~~~~
поле А = 45
поле Б = Целое8(А)
~~~~

#### 5.2.1. Преобразование из целого числа в целое число.

Общая формула преобразования:

~~~~
метод ЦелоеН(ЦелоеМ целое) ЦелоеН
~~~~

где буква М и Н обозначают одно из чисел: 8, 16, 32 или 64.

При преобразовании из меньшего в большее по разрядности число, старшие биты заполняются знаковым битом, то есть 0 для положительных чисел и 1 для отрицательных. При преобразовании из большего меньшее по разрядности число, старшие разряды просто удаляются.

Пример преобразования типа Целое в тип Целое8:

~~~~
поле А = 255
поле Б = Целое8(А) // Б = -1
~~~~

#### 5.2.2. Преобразование из счётного числа в целое число.

Общая формула преобразования:

~~~~
метод ЦелоеН(СчётноеМ счётное) ЦелоеН
~~~~

где буква М и Н обозначают одно из чисел: 8, 16, 32 или 64.

При преобразовании из меньшего в большее по разрядности число, старшие биты заполняются 0. При преобразовании из большего меньшее по разрядности число, старшие разряды просто удаляются.

Примеры преобразования:

~~~~
поле А = Счётное(255)
поле Б = Целое8(А) // Б = -1
поле В = Целое16(А) // В = 255
~~~~

#### 5.2.3. Преобразование из дробного числа в целое число.

Общая формула преобразования:

~~~~
метод ЦелоеН(ДробноеМ дробное) ЦелоеН?
~~~~

где буква М обозначает одно из чисел 32 или 64, а буква Н обозначает одно из чисел: 8, 16, 32 или 64.

Если число с плавающей точкой преобразуется в целое, то дробная часть отбрасывается (округление в сторону 0). Если значение целой части не может быть представлено целым типом (слишком большое значение дробного числа, либо дробное имеет значение Бесконечность/ПлюсБесконечность/МинусБесконечность, либо дробное имеет значение НеЧисло), то результат — не определён.

Примеры преобразования:

~~~~
поле А = Дробное(255.5)
поле Б = Целое8(А) // Б = Пусто
поле В = Целое16(А) // В = Целое16?(255)
~~~~

#### 5.2.4. Преобразование из строки в целое число.

Общая формула преобразования:

~~~~
метод ЦелоеН(Строка строка) ЦелоеН?
~~~~

где буква Н обозначает одно из чисел: 8, 16, 32 или 64.

Если строка представляет собой последовательность символов, как у литерала целого или шестнадцатеричного числа, то такая строка преобразуется в Целое число. В ином случае функция преобразования возвращает значение Пусто. Если значение числа записанное в строке не может вместиться в размер числа, то результатом преобразования также будет значение Пусто.

Примеры преобразования:

~~~~
поле строка1 = "123"
поле число1 = Целое(строка1) // число1 = Целое?(123)

поле строка2 = "-123"
поле число2 = Целое(строка2) // число2 = Целое?(-123)

поле строка3 = "123.1"
поле число3 = Целое(строка3) // число3 = Пусто
~~~~

#### 5.2.5. Преобразование из булева числа в целое число.

Общая формула преобразования:

~~~~
метод ЦелоеН(Буль буль) ЦелоеН
~~~~

где буква Н обозначает одно из чисел: 8, 16, 32 или 64.

Значение "Нет" преобразуется в число 0, значение "Да" преобразуется в число 1 для любого типа из линейки целых чисел.

Примеры преобразования:

~~~~
поле А = Целое(Нет) // А = 0
поле Б = Целое8(Да) // Б = 1
~~~~

#### 5.2.6. Преобразование из целого числа в счётное число.

Общая формула преобразования:

~~~~
метод СчётноеН(ЦелоеМ целое) СчётноеН
~~~~

где буква М и Н обозначают одно из чисел: 8, 16, 32 или 64.

При преобразовании из меньшего в большее по разрядности число, старшие биты заполняются знаковым битом, то есть 0 для положительных чисел и 1 для отрицательных. При преобразовании из большего меньшее по разрядности число, старшие разряды просто удаляются.

Пример преобразования типа Целое в тип Счётное8:

~~~~
поле А = -1
поле Б = Счётное8(А) // Б = 255
~~~~

#### 5.2.7. Преобразование из счётного числа в счётное число.

Общая формула преобразования:

~~~~
метод СчётноеН(СчётноеМ счётное) СчётноеН
~~~~

где буква М и Н обозначают одно из чисел: 8, 16, 32 или 64.

При преобразовании из меньшего в большее по разрядности число, старшие биты заполняются 0. При преобразовании из большего меньшее по разрядности число, старшие разряды просто удаляются.

Примеры преобразования:

~~~~
поле А = Счётное(256)
поле Б = Счётное8(А) // Б = 0
поле В = Счётное16(А) // В = 256
~~~~

#### 5.2.8. Преобразование из дробного числа в счётное число.

Общая формула преобразования:

~~~~
метод СчётноеН(ДробноеМ дробное) СчётноеН?
~~~~

где буква М обозначает одно из чисел 32 или 64, а буква Н обозначает одно из чисел: 8, 16, 32 или 64.

Если число с плавающей точкой преобразуется в счётное, то дробная часть отбрасывается (округление в сторону 0). Если значение целой части не может быть представлено счётным типом (слишком большое значение дробного числа, либо дробное имеет значение Бесконечность/ПлюсБесконечность/МинусБесконечность, либо дробное имеет значение НеЧисло), то результат — не определён.

Примеры преобразования:

~~~~
поле А = Дробное(256.5)
поле Б = Счётное8(А) // Б = Пусто
поле В = Счётное16(А) // В = Целое16?(255)
~~~~

#### 5.2.9. Преобразование из строки в счётное число.

Общая формула преобразования:

~~~~
метод СчётноеН(Строка строка) СчётноеН?
~~~~

где буква Н обозначает одно из чисел: 8, 16, 32 или 64.

Если строка представляет собой последовательность символов, как у литерала целого или шестнадцатеричного числа, то такая строка преобразуется в Счётное число. В ином случае функция преобразования возвращает значение Пусто. Если значение числа записанное в строке не может вместиться в размер числа, то результатом преобразования также будет значение Пусто.

Примеры преобразования:

~~~~
поле строка1 = "123"
поле число1 = Счётное(строка1) // число1 = Счётное?(123)

поле строка2 = "-123"
поле число2 = Счётное(строка2) // число2 = Счётное?(Пусто)

поле строка3 = "123.1"
поле число3 = Счётное(строка3) // число3 = Счётное?(Пусто)
~~~~

#### 5.2.10. Преобразование из булева числа в счётное число.

Общая формула преобразования:

~~~~
метод СчётноеН(Буль буль) СчётноеН
~~~~

где буква Н обозначает одно из чисел: 8, 16, 32 или 64.

Значение "Нет" преобразуется в число 0, значение "Да" преобразуется в число 1 для любого типа из линейки счётных чисел.

Примеры преобразования:

~~~~
поле А = Счётное(Нет) // А = 0
поле Б = Счётное8(Да) // Б = 1
~~~~

#### 5.2.11. Преобразование из целого числа в дробное число.

Общая формула преобразования:

~~~~
метод ДробноеН(ЦелоеМ целое) ДробноеН
~~~~

где буква М обозначает одно из чисел: 8, 16, 32 или 64, а Н - одно из чисел: 32 или 64.

Целое число преобразуется в дробное с учётом точности дробного числа.

Пример преобразования типа Целое в тип Дробное:

~~~~
поле А = -1
поле Б = Дробное(А) // Б = -1.0
~~~~

#### 5.2.12. Преобразование из счётного числа в дробное число.

Общая формула преобразования:

~~~~
метод ДробноеН(СчётноеМ счётное) ДробноеН
~~~~

где буква М обозначает одно из чисел: 8, 16, 32 или 64, а Н - одно из чисел: 32 или 64.

Счётное число преобразуется в дробное с учётом точности дробного числа.

Примеры преобразования:

~~~~
поле А = Счётное(256)
поле Б = Дробное(А) // Б = 256.0
~~~~

#### 5.2.13. Преобразование из дробного числа в дробное число.

Общая формула преобразования:

~~~~
метод ДробноеН(ДробноеМ дробное) ДробноеН
~~~~

где буквы М и Н обозначает одно из чисел 32 или 64.

Дробное число преобразуется в ближайшее возможное дробное число. Если дробное число преобразуется в дробное число меньшей точности и выходит за возможный ранг, то он преобразуется в значение ПлюсБесконечность или МинусБесконечность. 

Примеры преобразования:

~~~~
поле А = 256.5
поле Б = Дробное32(А) // Б = 256.5

поле В = ПлюсБесконечность
поле Г = Дробное32(В) // Г = ПлюсБесконечность
~~~~

#### 5.2.14. Преобразование из строки в дробное число.

Общая формула преобразования:

~~~~
метод ДробноеН(Строка строка) ДробноеН
~~~~

где буква Н обозначает одно из чисел 32 или 64.

Если строка представляет собой последовательность символов, как у литерала целого, шестнадцатеричного числа или числа с плавающей точкой, то такая строка преобразуется в Счётное число. В ином случае функция преобразования возвращает значение НеЧисло. Если значение числа записанное в строке не может вместиться в размер числа, то результатом преобразования будет значение ПлюсБесконечность или МинусБесконечность. Кроме того, есть слудющий правила:

* Знак, разделяющий целую и дробную часть может быть как точка (".") так и запятая (",").
* Дробное число со значением плюс бесконечность может быть записана следующими строковыми значениями: "∞", "+∞", "Бесконечность", "ПлюсБесконечность".
* Дробное число со значением минус бесконечность может быть записана следующими строковыми значениями: "-∞", "МинусБесконечность".

Примеры преобразования:

~~~~
поле строка1 = "123"
поле число1 = Дробное(строка1) // число1 = 123

поле строка2 = "-123"
поле число2 = Дробное(строка2) // число2 = -123

поле строка3 = "123.1"
поле число3 = Дробное(строка3) // число3 = 123.1
~~~~

#### 5.2.15. Преобразование из булева числа в дробное число.

Общая формула преобразования:

~~~~
метод ДробноеН(Буль буль) ДробноеН
~~~~

где буква Н обозначает одно из чисел 32 или 64.

Значение "Нет" преобразуется в число 0.0, значение "Да" преобразуется в число 1.0 для любого типа из линейки дробных чисел.

Примеры преобразования:

~~~~
поле А = Дробное(Нет) // А = 0.0
поле Б = Дробное32(Да) // Б = 1.0
~~~~

#### 5.2.16. Преобразование из целого числа в строку.

Общая формула преобразования:

~~~~
метод Строка(ЦелоеМ целое) Строка
~~~~

где буква М обозначает одно из чисел: 8, 16, 32 или 64.

Целое число преобразуется в строку. В начале строки может стоять знак минус для отрицательного числа, а затем следует последовательность цифр.

Пример преобразования типа Целое в тип Строка:

~~~~
поле А = -1
поле Б = Строка(А) // Б = "-1"
~~~~

#### 5.2.17. Преобразование из счётного числа строку.

Общая формула преобразования:

~~~~
метод Строка(СчётноеМ счётное) Строка
~~~~

где буква М обозначает одно из чисел: 8, 16, 32 или 64.

Счётное число преобразуется в строку. Преобразованная строка представляет собой последовательность цифр.

Примеры преобразования:

~~~~
поле А = Счётное(256)
поле Б = Строка(А) // Б = "256"
~~~~

#### 5.2.18. Преобразование из дробного числа строку.

Общая формула преобразования:

~~~~
метод Строка(ДробноеМ дробное) Строка
~~~~

где буква М обозначает одно из чисел 32 или 64.

Числа, чей модуль находится в пределах от 0.0001 до 10000 преобразуются в обычную запись числа с плавающей точкой. Если длина получившейся строки больше 10, то дробная часть обрезается справа так, чтобы общая длина строки вмещалась в 10 символов. Символ ".", отделяющий целую и дробную часть числа превращается в символ ",".

Если модуль преобразуемого числа меньше 0.0001 или больше 10000, то она преобразуется в экспоненциальную запись числа с плавающей точкой. Если длина получившейся строки больше 10, то дробная часть мантиссы обрезается справа так, чтобы общая длина строки вмещалась в 10 символов. Символ ".", отделяющий целую и дробную часть числа превращается в символ ",".

Если значение преобразуемого числа равно "НеЧисло", то оно преобразуется в строку "НеЧисло". Если значение равно плюс бесконечность, то оно преобразуется "∞", если значение равно минус бесконечность, то оно преобразуется в "-∞".

Примеры преобразования:

~~~~
поле А = 256.5
поле Б = Строка(А) // Б = "256.5"

поле В = ПлюсБесконечность
поле Г = Строка(В) // Г = "∞"
~~~~

#### 5.2.19. Преобразование из строки в строку.

Общая формула преобразования:

~~~~
метод Строка(Строка строка) Строка
~~~~

Фактически это копирование строки.

Примеры преобразования:

~~~~
поле строка1 = "АБВ"
поле строка2 = Строка(строка1) // строка2 = "АБВ"
~~~~

#### 5.2.20. Преобразование из булева числа в строку.

Общая формула преобразования:

~~~~
метод Строка(Буль буль) Строка
~~~~

Значение "Нет" преобразуется в строку "Нет", значение "Да" преобразуется в строку "Да".

Примеры преобразования:

~~~~
поле А = Строка(Нет) // А = "Нет"
поле Б = Строка(Да) // Б = "Да"
~~~~

#### 5.2.21. Преобразование из целого числа в булево число.

Общая формула преобразования:

~~~~
метод Буль(ЦелоеМ целое) Буль?
~~~~

где буква М обозначает одно из чисел: 8, 16, 32 или 64.

Если целое число равно 0, то оно преобразуется в булево значение "Нет". Если целое число равно 1, то оно преобразуется в булево значение "Да". В остальных случаях функция выдает значение Пусто.

Пример преобразования типа Целое в тип Буль:

~~~~
поле А = -1
поле Б = Буль(А) // Б = Пусто

поле В = 1
поле Г = Буль(В) // В = "Да"
~~~~

#### 5.2.22. Преобразование из счётного числа булево число.

Общая формула преобразования:

~~~~
метод Буль(СчётноеМ счётное) Буль?
~~~~

где буква М обозначает одно из чисел: 8, 16, 32 или 64.

Если счётное число равно 0, то оно преобразуется в булево значение "Нет". Если счётное число равно 1, то оно преобразуется в булево значение "Да". В остальных случаях функция выдает значение Пусто.

Примеры преобразования:

~~~~
поле А = Счётное(25)
поле Б = Буль(А) // Б = Пусто

поле В = Счётное(1)
поле Г = Буль(В) // В = "Да"
~~~~

#### 5.2.23. Преобразование из дробного числа булево число.

Общая формула преобразования:

~~~~
метод Буль(ДробноеМ дробное) Буль?
~~~~

где буква М обозначает одно из чисел 32 или 64.

Если дробное число равно 0.0, то оно преобразуется в булево значение "Нет". Если дробное число равно 1.0, то оно преобразуется в булево значение "Да". В остальных случаях функция выдает значение Пусто.

Примеры преобразования:

~~~~
поле А = 256.5
поле Б = Буль(А) // Б = Пусто

поле В = 1.0
поле Г = Буль(В) // Г = "Да"
~~~~

#### 5.2.24. Преобразование из строки в булево число.

Общая формула преобразования:

~~~~
метод Буль(Строка строка) Буль?
~~~~

В значения Да/Нет преобразуются следующие строковые пары: "1"/"0", "+"/"-", "Да"/"Нет", "д"/"н", "Yes"/"No", "Y"/"N". Каждая буква может быть записана в любом регистре. В остальных случаях функция возвращает значение Пусто.

Примеры преобразования:

~~~~
поле А = "дА"
поле Б = Буль(А) // Б = "Да"
~~~~

#### 5.2.25. Преобразование из булева числа в булево число.

Общая формула преобразования:

~~~~
метод Буль(Буль буль) Буль
~~~~

Фактически это копирование булевого значения.

Примеры преобразования:

~~~~
поле А = Буль(Нет) // А = "Нет"
поле Б = Буль(Да) // Б = "Да"
~~~~

### 5.3. Операция скобки (операция изменения приоритетов).

Операция скобок меняет приоритет выполнения операций.

Грамматическое описание:

~~~~
Выражение = ОткрывающаясяСкобка {ПробельныйСимвол|КонецСтроки} Выражение {ПробельныйСимвол|КонецСтроки} ЗакрывающаясяСкобка
~~~~

Общая формула преобразования:

~~~~
метод Скобки(Тип Выражение1) Тип
~~~~

Тип выходного выражения равен типу входного выражения. Тип может быть любой.

Пример:

~~~~
поле А = ( 35)
~~~~

### 5.4. Операция выбора элемента.

Операция выбора элемента обозначается через символ "." и необходим для выбора поля или метода класса.

Грамматическое описание:

~~~~
Выражение = Выражение Точка Выражение
~~~~

Формула:

~~~~
<Имя метода>.<Имя метода>
~~~~

Пример:

~~~~
Кар.Печатать(3.Чётное())
~~~~

### 5.5. Операция обращения к методу.

Грамматическое описание:

~~~~
Выражение = Идентификатор ОткрывающаясяСкобка [ {ПробельныйСимвол} Выражение {ПробельныйСимвол} {Запятая {ПробельныйСимвол} Выражение {ПробельныйСимвол} } ] ЗакрывающаясяСкобка
~~~~

Формула:

~~~~
<Имя метода>([Параметр1 [, Параметр2 [..., ПараметрН]]])
~~~~

Операция обращения к методу обозначается через имя метода и последующим за ним круглых скобок. Внутри скобок через запятую перечисляются параметры метода, если они есть.
Вычисления выражений в аргументах функций происходят в том порядке, в котором они определены в функции.

Пример:

~~~~
Кар.Печатать(3.Чётное())
~~~~

### 5.6. Операция неопределённости.

"?" - оператор, обозначающий неопределенность типа.

Грамматическое описание:

~~~~
Выражение = Выражение {ПробельныйСимвол} Неопределённость
~~~~

Формула:

~~~~
<Тип>?
~~~~

Оператор неопределенность применяется к типу. В результате получается неопределённый тип. Неопределённый тип может принимать те же значения, что и определённый тип, но имеет дополнительное значение Пусто.

Пример:

~~~~
поле к1 = Целое?(Пусто)
поле к2 = Целое?(4)
~~~~

### 5.7. Операция определённости.

"!" - оператор разрешающий неопределенность.

Грамматическое описание:

~~~~
Выражение = Выражение {ПробельныйСимвол} Определённость {ПробельныйСимвол} Выражение
~~~~

Формула:

~~~~
метод Определённость(Тип? поле1, Тип поле2) Тип
~~~~

Оператор определённости применяется к неопределённому типу и возвращает соответствующий ему определённый тип. В случае, если левое выражение не имеет значение пусто, то возвращется значение левого выражения, в противном случае значение правого выражения.

Пример:

~~~~
поле к = Целое?(Пусто)
...

Кар.Печатать(к ! 0)
~~~~

В этом примере печатается значение к или 0, если к имеет значение пусто.

### 5.8. Операция унарный плюс.

"+" - унарный плюс.

Грамматическое описание:

~~~~
Выражение = Плюс {ПробельныйСимвол} Выражение
~~~~

Формула для целых и счётных типов:

~~~~
метод УнарныйПлюс(Тип поле) Тип?
метод УнарныйПлюс(Тип? поле) Тип?
~~~~

Где тип - это любой целый или счётный тип. Результат операции возвращает входное значение. В результате работы операции значение Пусто не может быть получено, но для совместимости с другими арифметическими операциями выходной тип является неопределённым.

В случае с неопределённым входным типом, операция работает также, как с определённым, но с дополнением. Если входное значение Пусто, то и выходное значение также будет Пусто.

Формула для дробных чисел:

~~~~
метод УнарныйПлюс(Тип поле) Тип
метод УнарныйПлюс(Тип? поле) Тип?
~~~~

Где тип - это любой дробный тип. Результат операции возвращает входное значение. Частный случай: +НеЧисло = НеЧисло.

Пример:

~~~~
поле А = 5
поле Б = +А // Б = Целое?(5)
~~~~

### 5.9. Операция унарный минус.

"-" - унарный минус.

Грамматическое описание:

~~~~
Выражение = Минус {ПробельныйСимвол} Выражение
~~~~

Формула для целых типов:

~~~~
метод УнарныйМинус(Тип поле) Тип?
метод УнарныйМинус(Тип? поле) Тип?
~~~~

Где тип - это любой целый тип. Результат операции возвращает противоположное число. В результате работы операции значение Пусто может быть получено в случае арифметического переполнения.

В случае с неопределённым входным типом, операция работает также, как с определённым, но с дополнением. Если входное значение Пусто, то и выходное значение также будет Пусто.

Формула для дробных чисел:

~~~~
метод УнарныйМинус(Тип поле) Тип
метод УнарныйМинус(Тип? поле) Тип?
~~~~

Где тип - это любой дробный тип. Результат операции возвращает противоположное число. Частный случай: -НеЧисло = НеЧисло.

В случае с неопределённым входным типом, операция работает также, как с определённым, но с дополнением. Если входное значение Пусто, то и выходное значение также будет Пусто.

Пример:

~~~~
поле А = 5
поле Б = -А // Б = Целое?(-5)

поле В = Целое8(-128)
поле Г = -В // Г = Целое?(Пусто)
~~~~

### 5.10. Операция сложения.

"+" - сложение.

Грамматическое описание:

~~~~
Выражение = Выражение {ПробельныйСимвол} Плюс {ПробельныйСимвол} Выражение
~~~~

Формула для целых и счётных типов:

~~~~
метод Плюс(Тип поле1, Тип поле2) Тип?
метод Плюс(Тип? поле1, Тип поле2) Тип?
метод Плюс(Тип поле1, Тип? поле2) Тип?
метод Плюс(Тип? поле1, Тип? поле2) Тип?
~~~~

Где тип - это любой целый или счётный тип. Результатом операции является сумма двух чисел. В результате работы операции значение Пусто может быть получено в случае арифметического переполнения.

В случае если хотя бы одно из входных значений имеет неопределённый тип и значение Пусто, то и выходное значение имеет значение Пусто.

Формула для дробных чисел:

~~~~
метод Плюс(Тип поле1, Тип поле2) Тип
метод Плюс(Тип? поле1, Тип поле2) Тип?
метод Плюс(Тип поле1, Тип? поле2) Тип?
метод Плюс(Тип? поле1, Тип? поле2) Тип?
~~~~

Где тип - это любой дробный тип. Результатом операции является сумма двух чисел.

В случае если хотя бы одно из входных значений имеет неопределённый тип и значение Пусто, то и выходное значение имеет значение Пусто.

Формула для строк:

~~~~
метод Плюс(Строка поле1, Строка поле2) Строка
метод Плюс(Строка? поле1, Строка поле2) Строка?
метод Плюс(Строка поле1, Строка? поле2) Строка?
метод Плюс(Строка? поле1, Строка? поле2) Строка?
~~~~

Результатом операции является конкатенация ("склеивание") двух строк.

В случае если хотя бы одно из входных значений имеет неопределённый тип и значение Пусто, то и выходное значение имеет значение Пусто.

Пример:

~~~~
поле А = 5 + 3 // А = Целое?(8)
поле Б = "Привет, " + "мир!" // Б = "Привет, мир!"
поле В = Целое8(127) + Целое8(1) // В = Пусто
~~~~

### 5.11. Операция вычитания.

"-" - вычитание.

Грамматическое описание:

~~~~
Выражение = Выражение {ПробельныйСимвол} Минус {ПробельныйСимвол} Выражение
~~~~

Формула для целых и счётных типов:

~~~~
метод Минус(Тип поле1, Тип поле2) Тип?
метод Минус(Тип? поле1, Тип поле2) Тип?
метод Минус(Тип поле1, Тип? поле2) Тип?
метод Минус(Тип? поле1, Тип? поле2) Тип?
~~~~

Где тип - это любой целый или счётный тип. Результатом операции является разность двух чисел. В результате работы операции значение Пусто может быть получено в случае арифметического переполнения.

В случае если хотя бы одно из входных значений имеет неопределённый тип и значение Пусто, то и выходное значение имеет значение Пусто.

Формула для дробных чисел:

~~~~
метод Минус(Тип поле1, Тип поле2) Тип
метод Минус(Тип? поле1, Тип поле2) Тип?
метод Минус(Тип поле1, Тип? поле2) Тип?
метод Минус(Тип? поле1, Тип? поле2) Тип?
~~~~

Где тип - это любой дробный тип. Результатом операции является разность двух чисел.

В случае если хотя бы одно из входных значений имеет неопределённый тип и значение Пусто, то и выходное значение имеет значение Пусто.

Пример:

~~~~
поле А = 5 - 6 // А = Целое?(-1)
поле Б = А - 5 // Б = Целое?(-6)
~~~~

### 5.12. Операция умножение.

"*" - умножение.

Грамматическое описание:

~~~~
Выражение = Выражение {ПробельныйСимвол} Умножить {ПробельныйСимвол} Выражение
~~~~

Формула для целых и счётных типов:

~~~~
метод Умножить(Тип поле1, Тип поле2) Тип?
метод Умножить(Тип? поле1, Тип поле2) Тип?
метод Умножить(Тип поле1, Тип? поле2) Тип?
метод Умножить(Тип? поле1, Тип? поле2) Тип?
~~~~

Где тип - это любой целый или счётный тип. Результатом операции является произведение двух чисел. В результате работы операции значение Пусто может быть получено в случае арифметического переполнения.

В случае если хотя бы одно из входных значений имеет неопределённый тип и значение Пусто, то и выходное значение имеет значение Пусто.

Формула для дробных чисел:

~~~~
метод Умножить(Тип поле1, Тип поле2) Тип
метод Умножить(Тип? поле1, Тип поле2) Тип?
метод Умножить(Тип поле1, Тип? поле2) Тип?
метод Умножить(Тип? поле1, Тип? поле2) Тип?
~~~~

Где тип - это любой дробный тип. Результатом операции является произведение двух чисел.

В случае если хотя бы одно из входных значений имеет неопределённый тип и значение Пусто, то и выходное значение имеет значение Пусто.

Пример:

~~~~
поле А = 5 * 6 // А = Целое?(30)
поле Б = А * 5 // Б = Целое?(150)
~~~~

### 5.14. Операция деление.

"/" - деление.

Грамматическое описание:

~~~~
Выражение = Выражение {ПробельныйСимвол} Разделить {ПробельныйСимвол} Выражение
~~~~

Формула для целых и счётных типов:

~~~~
метод Умножить(Тип поле1, Тип поле2) Тип?
метод Умножить(Тип? поле1, Тип поле2) Тип?
метод Умножить(Тип поле1, Тип? поле2) Тип?
метод Умножить(Тип? поле1, Тип? поле2) Тип?
~~~~

Где тип - это любой целый или счётный тип. Результатом операции является целочисленное частное двух чисел. В результате работы операции значение Пусто может быть получено в случае арифметического переполнения или деления на 0.

В случае если хотя бы одно из входных значений имеет неопределённый тип и значение Пусто, то и выходное значение имеет значение Пусто.

Формула для дробных чисел:

~~~~
метод Умножить(Тип поле1, Тип поле2) Тип
метод Умножить(Тип? поле1, Тип поле2) Тип?
метод Умножить(Тип поле1, Тип? поле2) Тип?
метод Умножить(Тип? поле1, Тип? поле2) Тип?
~~~~

Где тип - это любой дробный тип. Результатом операции является частное двух чисел.

В случае если хотя бы одно из входных значений имеет неопределённый тип и значение Пусто, то и выходное значение имеет значение Пусто.

Пример:

~~~~
поле А = 7 / 2 // А = Целое?(3)
поле Б = 7.0 / 2.0 // Б = 3.5
~~~~

### 5.16. Операция остаток от деления.

"%" - остаток.

Грамматическое описание:

~~~~
Выражение = Выражение {ПробельныйСимвол} Остаток {ПробельныйСимвол} Выражение
~~~~

Формула:

~~~~
метод Умножить(Тип поле1, Тип поле2) Тип?
метод Умножить(Тип? поле1, Тип поле2) Тип?
метод Умножить(Тип поле1, Тип? поле2) Тип?
метод Умножить(Тип? поле1, Тип? поле2) Тип?
~~~~

Где тип - это любой целый или счётный тип. Результатом операции является целочисленный остаток от деления двух чисел. В результате работы операции значение Пусто может быть получено в случае арифметического переполнения или деления на 0.

В случае если хотя бы одно из входных значений имеет неопределённый тип и значение Пусто, то и выходное значение имеет значение Пусто.

~~~~
поле А = 5 / 3 // А = Целое?(2)
поле Б = 6 / 0 // Б = Целое?(Пусто)
~~~~

### 5.18. Операция побитовое И.

"би" - побитовое И.

Грамматическое описание:

~~~~
Выражение = Выражение ПробельныйСимвол{ПробельныйСимвол} ПобитовоеИ ПробельныйСимвол{ПробельныйСимвол} Выражение
~~~~

Формула:

~~~~
метод ПобитовоеИ(Тип поле1, Тип поле2) Тип
метод ПобитовоеИ(Тип? поле1, Тип поле2) Тип?
метод ПобитовоеИ(Тип поле1, Тип? поле2) Тип?
метод ПобитовоеИ(Тип? поле1, Тип? поле2) Тип?
~~~~

Где тип - это любой целый или счётный тип. Результатом операции является побитовое И двух чисел.

В случае если хотя бы одно из входных значений имеет неопределённый тип и значение Пусто, то и выходное значение имеет значение Пусто.

Пример:

~~~~
поле А = Целое8(5) // 00000101 в двоичной системе.
поле Б = Целое8(3) // 00000011 в двоичной системе.
поле В = А би Б // В = 1, или 00000001 в двоичной системе.
~~~~

### 5.19. Операция побитовое ИЛИ.

"били" - побитовое ИЛИ.

Грамматическое описание:

~~~~
Выражение = Выражение ПробельныйСимвол{ПробельныйСимвол} ПобитовоеИЛИ ПробельныйСимвол{ПробельныйСимвол} Выражение
~~~~

Формула:

~~~~
метод ПобитовоеИЛИ(Тип поле1, Тип поле2) Тип
метод ПобитовоеИЛИ(Тип? поле1, Тип поле2) Тип?
метод ПобитовоеИЛИ(Тип поле1, Тип? поле2) Тип?
метод ПобитовоеИЛИ(Тип? поле1, Тип? поле2) Тип?
~~~~

Где тип - это любой целый или счётный тип. Результатом операции является побитовое ИЛИ двух чисел.

В случае если хотя бы одно из входных значений имеет неопределённый тип и значение Пусто, то и выходное значение имеет значение Пусто.

Пример:

~~~~
поле А = Целое8(5) // 00000101 в двоичной системе.
поле Б = Целое8(3) // 00000011 в двоичной системе.
поле В = А били Б // В = 7, или 00000111 в двоичной системе.
~~~~

### 5.20. Операция побитовое исключающее ИЛИ.

"билине" - побитовое исключающее ИЛИ.

Грамматическое описание:

~~~~
Выражение = Выражение ПробельныйСимвол{ПробельныйСимвол} ПобитовоеИсключающееИЛИ ПробельныйСимвол{ПробельныйСимвол} Выражение
~~~~

Формула:

~~~~
метод ПобитовоеИсключающееИЛИ(Тип поле1, Тип поле2) Тип
метод ПобитовоеИсключающееИЛИ(Тип? поле1, Тип поле2) Тип?
метод ПобитовоеИсключающееИЛИ(Тип поле1, Тип? поле2) Тип?
метод ПобитовоеИсключающееИЛИ(Тип? поле1, Тип? поле2) Тип?
~~~~

Где тип - это любой целый или счётный тип. Результатом операции является побитовое исключающее ИЛИ двух чисел.

В случае если хотя бы одно из входных значений имеет неопределённый тип и значение Пусто, то и выходное значение имеет значение Пусто.

Пример:

~~~~
поле А = Целое8(5) // 00000101 в двоичной системе.
поле Б = Целое8(3) // 00000011 в двоичной системе.
поле В = А били Б // В = 6, или 00000110 в двоичной системе.
~~~~

### 5.21. Операция побитовое НЕ.


"бне" - побитовое НЕ.

Грамматическое описание:

~~~~
Выражение = ПобитовоеНЕ ПробельныйСимвол{ПробельныйСимвол} Выражение
~~~~

Формула:

~~~~
метод ПобитовоеНЕ(Тип поле) Тип
метод ПобитовоеНЕ(Тип? поле) Тип?
~~~~

Где тип - это любой целый или счётный тип. Результатом операции является побитовое НЕ числа.

В случае если входное значение имеет неопределённый тип и равно Пусто, то и выходное значение имеет значение Пусто.

Пример:

~~~~
поле А = Целое8(6) // 00000110 в двоичной системе.
поле Б = бне А // Б = -7, или 11111001 в двоичной системе.
~~~~

### 5.22. Операция побитовый сдвиг вправо.

"вправо" - побитовый сдвиг вправо.

Грамматическое описание:

~~~~
Выражение = Выражение ПробельныйСимвол{ПробельныйСимвол} ПобитовыйСдвигВправо ПробельныйСимвол{ПробельныйСимвол} Выражение
~~~~

Формула:

~~~~
метод ПобитовыйСдвигВправо(Тип1 поле1, Тип2 поле2) Тип1
метод ПобитовыйСдвигВправо(Тип1? поле1, Тип2 поле2) Тип1?
метод ПобитовыйСдвигВправо(Тип1 поле1, Тип2? поле2) Тип1?
метод ПобитовыйСдвигВправо(Тип1? поле1, Тип2? поле2) Тип1?
~~~~

Где Тип1 и Тип2 - это любой целый или счётный тип. Результатом операции является побитовый сдвиг вправо числа поле1 на поле2 бит.

В случае если хотя бы одно из входных значений имеет неопределённый тип и значение Пусто, то и выходное значение имеет значение Пусто.

Пример:

~~~~
поле А = 8 вправо 2 // В двоичной системе 1000(2) вправо 2 = 10(2). Что в десятичной равно 2.
~~~~

### 5.23. Операция побитовый сдвиг влево.

"влево" - побитовый сдвиг влево.

Грамматическое описание:

~~~~
Выражение = Выражение ПробельныйСимвол{ПробельныйСимвол} ПобитовыйСдвигВлево ПробельныйСимвол{ПробельныйСимвол} Выражение
~~~~

Формула:

~~~~
метод ПобитовыйСдвигВлево(Тип1 поле1, Тип2 поле2) Тип1
метод ПобитовыйСдвигВлево(Тип1? поле1, Тип2 поле2) Тип1?
метод ПобитовыйСдвигВлево(Тип1 поле1, Тип2? поле2) Тип1?
метод ПобитовыйСдвигВлево(Тип1? поле1, Тип2? поле2) Тип1?
~~~~

Где Тип1 и Тип2 - это любой целый или счётный тип. Результатом операции является побитовый сдвиг влево числа поле1 на поле2 бит.

В случае если хотя бы одно из входных значений имеет неопределённый тип и значение Пусто, то и выходное значение имеет значение Пусто.

Пример:

~~~~
поле А = 1 влево 2 // В двоичной системе 1(2) влево 2 = 100(2). Что в десятичной равно 4.
~~~~

### 5.24. Операция проверка на равенство.

"==" - проверка на равенство.

Грамматическое описание:

~~~~
Выражение = Выражение {ПробельныйСимвол} Равно {ПробельныйСимвол} Выражение
~~~~

Формула:

~~~~
метод Равно(Тип поле1, Тип поле2) Буль
метод Равно(Тип? поле1, Тип поле2) Буль
метод Равно(Тип поле1, Тип? поле2) Буль
метод Равно(Тип? поле1, Тип? поле2) Буль
~~~~

Где Тип - это любой целый, счётный, дробный, строковый или булевый тип. Результатом операции является проверка на равенство и имеет булевый тип.

Для двух дробных чисел, если они оба имеют значение НеЧисло, результатом их сравнения будет значение Нет.

В случае если оба типа являются неопределенными и значение у обоих является Пусто, то результатом их сравнения будет значение Да.

Пример:

~~~~
поле А = 1
поле Б = 1 == Пусто // Б = Нет
поле В = 3 == 3 // В = Да
~~~~

### 5.25. Операция проверка на неравенство.

"!=" - проверка на неравенство.

Грамматическое описание:

~~~~
Выражение = Выражение {ПробельныйСимвол} НеРавно {ПробельныйСимвол} Выражение
~~~~

Формула:

~~~~
метод НеРавно(Тип поле1, Тип поле2) Буль
метод НеРавно(Тип? поле1, Тип поле2) Буль
метод НеРавно(Тип поле1, Тип? поле2) Буль
метод НеРавно(Тип? поле1, Тип? поле2) Буль
~~~~

Где Тип - это любой целый, счётный, дробный, строковый или булевый тип. Результатом операции является проверка на неравенство и имеет булевый тип. Результат сравнения на неравенство всегда противоположен результату сравнения на равенство.

Пример:

~~~~
поле А = 1
поле Б = 1 != Пусто // Б = Да
поле В = 3 != 3 // В = Нет
~~~~

### 5.26. Операция проверка больше.

"больше" - проверка больше.

Грамматическое описание:

~~~~
Выражение = Выражение ПробельныйСимвол{ПробельныйСимвол} Больше ПробельныйСимвол{ПробельныйСимвол} Выражение
~~~~

Формула:

~~~~
метод Больше(Тип поле1, Тип поле2) Буль
~~~~

Где Тип - это любой целый, счётный, дробный, строковый или булевый тип. Результатом операции является сравнение значений больше.

Для дробных чисел, если хотя бы одно из чисел имеет значение НеЧисло, то результатом сравнения будет значение Нет.

Для строковых значений сравнение происходит посимвольно, согласно номерам символов в кодировке Юникод.

Пример:

~~~~
поле А = 2 больше 3 // А = Нет
поле Б = 3 больше 2 // Б = Да
~~~~

### 5.27. Операция проверка больше или равно.

"бир" - проверка больше или равно.

Грамматическое описание:

~~~~
Выражение = Выражение ПробельныйСимвол{ПробельныйСимвол} БольшеИлиРавно ПробельныйСимвол{ПробельныйСимвол} Выражение
~~~~

Формула:

~~~~
метод БольшеИлиРавно(Тип поле1, Тип поле2) Буль
~~~~

Где Тип - это любой целый, счётный, дробный, строковый или булевый тип. Результатом операции является сравнение значений больше или равно.

Для дробных чисел, если хотя бы одно из чисел имеет значение НеЧисло, то результатом сравнения будет значение Нет.

Для строковых значений сравнение происходит посимвольно, согласно номерам символов в кодировке Юникод.

Пример:

~~~~
поле А = 2 больше 3 // А = Нет
поле Б = 3 больше 2 // Б = Да
~~~~

### 5.28. Операция проверка меньше.

"меньше" - проверка меньше.

Грамматическое описание:

~~~~
Выражение = Выражение ПробельныйСимвол{ПробельныйСимвол} Меньше ПробельныйСимвол{ПробельныйСимвол} Выражение
~~~~

Формула:

~~~~
метод Меньше(Тип поле1, Тип поле2) Буль
~~~~

Где Тип - это любой целый, счётный, дробный, строковый или булевый тип. Результатом операции является сравнение значений меньше.

Для дробных чисел, если хотя бы одно из чисел имеет значение НеЧисло, то результатом сравнения будет значение Нет.

Для строковых значений сравнение происходит посимвольно, согласно номерам символов в кодировке Юникод.

Пример:

~~~~
поле А = 2 меньше 3 // А = Да
поле Б = 3 меньше 2 // Б = Нет
~~~~

### 5.29. Операция проверка меньше или равно.

"мир" - проверка меньше или равно.

Грамматическое описание:

~~~~
Выражение = Выражение ПробельныйСимвол{ПробельныйСимвол} МеньшеИлиРавно ПробельныйСимвол{ПробельныйСимвол} Выражение
~~~~

Формула:

~~~~
метод МеньшеИлиРавно(Тип поле1, Тип поле2) Буль
~~~~

Где Тип - это любой целый, счётный, дробный, строковый или булевый тип. Результатом операции является сравнение значений меньше или равно.

Для дробных чисел, если хотя бы одно из чисел имеет значение НеЧисло, то результатом сравнения будет значение Нет.

Для строковых значений сравнение происходит посимвольно, согласно номерам символов в кодировке Юникод.

Пример:

~~~~
поле А = 2 мир 3 // А = Да
поле Б = 3 мир 2 // Б = Нет
~~~~

### 5.30. Операция логическое И.

"и" - логическое И.

Грамматическое описание:

~~~~
Выражение = Выражение ПробельныйСимвол{ПробельныйСимвол} ЛогическоеИ ПробельныйСимвол{ПробельныйСимвол} Выражение
~~~~

Формула:

~~~~
метод ЛогическоеИ(Буль поле1, Буль поле2) Буль
~~~~

Результатом операции является логическое И двух булевых переменных.

Пример:

~~~~
поле А = Да и Да // А = Да
поле Б = Да и Нет // Б = Нет
~~~~

### 5.31. Операция логическое ИЛИ.

"или" - логическое ИЛИ.

Грамматическое описание:

~~~~
Выражение = Выражение ПробельныйСимвол{ПробельныйСимвол} ЛогическоеИЛИ ПробельныйСимвол{ПробельныйСимвол} Выражение
~~~~

Формула:

~~~~
метод ЛогическоеИЛИ(Буль поле1, Буль поле2) Буль
~~~~

Результатом операции является логическое ИЛИ двух булевых переменных.

Пример:

~~~~
поле А = Да или Нет // А = Да
поле Б = Нет или Нет // Б = Нет
~~~~

### 5.32. Операция логическое НЕ.

"не" - логическое НЕ.

Грамматическое описание:

~~~~
Выражение = ЛогическоеНЕ ПробельныйСимвол{ПробельныйСимвол} Выражение
~~~~

Формула:

~~~~
метод ЛогическоеНЕ(Буль поле) Буль
~~~~

Результатом операции является логическое НЕ булевой переменной.

Пример:

~~~~
поле А = не Нет // А = Да
поле Б = не Да // Б = Нет
~~~~

### 5.33. Приоритет операций.

Ниже описан приоритет операций а также ассоциативность.

|Приоритет|Операция|Ассоциативность|Описание|
|---------|:------:|---------------|--------|
|1|()|слева направо|изменение приоритета операции, параметры при вызове метода, преобразование типов|
|2|. .метод(,,)|слева направо|обращение к элементу, вызов метода|
|3|?||неопределенность|
|4|!|слева направо|разрешение неопределенности|
|5|+ - не бне||унарный плюс, унарный минус, логическое НЕ, побитовое НЕ|
|6|* / % |слева направо|умножение, деление, остаток от деления|
|7|+ -|слева направо|сложение, вычитание|
|8|вправо влево|слева направо|побитовый сдвиг вправо, побитовый сдвиг влево|
|9|больше бир меньше мир|слева направо|больше, больше или равно, меньше, меньше или равно|
|10|== !=|слева направо|равно, не равно|
|11|би|слева направо|побитовое И|
|12|билине|слева направо|побитовое исключающее ИЛИ|
|13|били|слева направо|побитовое ИЛИ|
|14|и|слева направо|логическое И|
|15|или|слева направо|логическое ИЛИ|

Для логических операций "и", "или" используется неполное вычисление.
То есть, если есть несколько аргументов объединённых операцией "и", то вычисление производится до первой операции, вернувшей значение "Нет".
Аналогично, если есть несколько аргументов объединённых операцией "или", то вычисление производится до первой операции, вернувшей значение "Да".

## 6. Алгоритм.

### 6.1. Общее описание.

Алгоритм - это последовательность команд. Команды могут быть простыми или блочными.

Простые алгоритмы могут быть записаны в одну строку, блочные состоят из блоков, каждых из этих блоков также является алгоритмом.

В синтаксисе команд применяются специальные символы:

* `[]` - необязательный элемент. Может присутвовать 0 или 1 раз.

* `[]*` - необязательный множественный элемент. Может присутствовать 0, 1 или множество раз.

* `<>` - элемент, который является не конкретным словом, а его сущностью. Например `<Алгоритм>` является алгоритмом.

### 6.2. Вычисление выражения.

Команда запускает вычисление выражения.

Синтаксис:

~~~~
<Выражение>
~~~~

Вычисление выражения может быть использовано для вызова функции, или, используя неполное вычисление логических функций, можно вызывать не все функции подряд.

### 6.3. Объявление переменной.

Инициализация локальной переменной.

Синтаксис:

~~~~
поле <Идентификатор> = <Выражение>
~~~~

Объявление локальной переменной для данного блока в алгоритме. Область видимости от места объявления переменной до конца блока.
Имя переменной (Идентификатор) должно быть уникально в пределах текущего блока. В дочерних блоках переменная может перекрываться переменными в дочерних блоках, если они имеют одно и тоже имя.

При объявлении любого поля оно обязательно должно быть инициализировано. Тип переменной определяется по типу выражения справа от знака равенства. Тип переменной определяется при инициализации и далее не меняется.

### 6.4. Присваивание.

Синтаксис:

~~~~
<Идентификатор> = <Выражение>
~~~~

Присваивает переменной, стоящей слева некоторое значение, вычисляемое по формуле справа. обозначается символом "=". Множественное присваивание запрещено.
Переменная должна быть объявлена заранее. Тип выражения справа должен совпадать с типом переменной.

### 6.5. Блок области видимости.

Синтаксис:

~~~~
блок:
    <Алгоритм>
~~~~

Принцип работы: выполняется тело блока.

Можно применять для организации тела функции. Кроме того, происходит локализация области видимости переменных, объявленных внутри блока. При выходе из блока такие переменные уничтожаются.

### 6.6. Блок раскрытия неопределенности.

Синтаксис:

~~~~
раскрыть <Идентификатор>:
    <Алгоритм>
[иначе:
    <Алгоритм>]
~~~~

Блок пытается раскрыть переменную с неопределённостью. Если все переменная раскрыта (не имеет значения "Пусто"), то выполняется тело блока. В теле блока раскрытая переменная уже имеют определённый тип. Если переменная не раскрыта (имеет значение Пусто), то запускается блок "иначе". Блок "иначе" является необязательным.

### 6.7. Условный блок.

Синтаксис условного блока:

~~~~
если <Выражение>:
    <Алгоритм>
[иначе если <Выражение>:
    <Алгоритм>
]*
[иначе:
    <Алгоритм>]
~~~~

Условный блок разделяется на одно или несколько подблоков. Сначала идёт обязательный подблок "если", затем могут идти подблоки "иначе если" (от 0 до бесконечности), и затем может идти подблок "иначе" (0 или 1).

Подблок "если". Сначала пишется ключевое слово "если" затем идет условие, а затем двоеточие. Условие - это выражение, которое возвращает значение типа Буль.

Подблок "иначе если" работает подобным способом. Сначала пишутся ключевые слова "иначе если" затем идет условие, а затем двоеточие. Условие - это выражение, которое возвращает переменную типа Буль.

В подблоке иначе сначала пишется ключевое слово "иначе", а затем идет двоеточие.

Общая схема работы блока. Проверяется условие в блоке "если". Если условие возвращает значение "Да", то выполняется тело блока и блок завершает свою работу, в противном случае поочередно проверяются условия подблоков "иначе если". Если какое-либо условие возвращает значение "Да", то выполняется соответствующее ему тело подблока и блок завершает свою работу.

Если ни одно условие не вернуло значение "Да" и есть подблок "иначе", то выполняется тело подблока "иначе" и блок завершает работу. Если ни одно условие не вернуло значение "да" и нет подблока "иначе", то блок завершает работу.

### 6.8. Блок цикла по условию.

Синтаксис условного блока:

~~~~
повторить пока <Выражение>:
    <Алгоритм>
~~~~

Блок проверяет сначала Выражение, которое возвращает значение типа Буль. Если значение равно Да, выполняется алгоритм внутри цикла. Затем Выражение проверяется снова и снова выполняется алгоритм. И так до тех пор, пока значение выражения не станет равным Нет. Если значение выражения равно Нет, то блок заканчивает свою работу.

## 7. Корневые элементы.

### 7.1. Константы и переменные.

Синтаксис объявления поля:

~~~~
[<Модификаторы>] поле <Идентификатор> = <Выражение>
~~~~
Синтаксис объявления константы:

~~~~
[<Модификаторы>] конст <Идентификатор> = <Выражение>
~~~~

Объявление переменной или константы модуля.

Для константы применяется ключевое слово "конст", для переменной ключевое слово "поле".

Любая константа и переменная должна быть проинициализированна. Тип константы или переменной можно однозначно вывести из правой части присвоения.

Модификаторы полей и констант описаны в пункте 7.1.1.

Пример:

~~~~
поле а = НОД(36, 24) // Зависит от типа, который возвращает метод НОД
конст б = (3 + 5) !0 // Тип Целое.
~~~~

#### 7.1.1. Модификаторы поля.

Если поле является полем класса, то он имеет модификаторы

Модификаторы статичности:
* стат - статическое
* динамическое - динамическое поле (значение по-умолчанию)

Модификаторы области видимости:
* закрытое - видимо только внутри класса (значение по-умолчанию)
* защищённое - видимо внутри класса и его наследников.
* открытое - видимо всем.

Каждый из блоков модификаторов может встречаться только один раз. В версии 0.1 реализована только комбинация модификаторов "стат закрытое". Остальные комбинации выдают ошибку.

### 7.2. Методы (функции).

Синтаксис:

~~~~
[<Модификаторы>] метод <ИмяМетода>([<Тип> <Идентификатор> [, <Тип> <Идентификатор>]* ]) [<ВыходнойТип>]:
    <Алгоритм>
~~~~

Сначала следуют модификаторы, затем ключевое слово "метод", затем имя метода, затем в скобках перечисление входных переменных или пустые скобки, если у метода нет параметров, затем тип возвращаемого значения, если метод возвращает результат, затем ставится двоеточие.

#### 7.2.1. Модификаторы метода.

Модификаторы статичности:

* стат - статическая
* динамический - не статический метод (значение по-умолчанию)

Модификаторы области видимости:

* закрытый - видима только внутри класса (значение по-умолчанию)
* защищённый - видима внутри класса и его наследников.
* открытый - видима всем.

Модификаторы финализации:

* финализированный - финализированное (значение по-умолчанию)
* наследуемый - не финализирована. (Сразу же становится динамическим методом.)

Модификатор перегруженности метода:

* перегруженный - обязательный модификтор, если метод перекрывает родительский. В этом случае он также становится финализируемым по-умолчанию. Необходимо добавить в родительский метод модификатор "наследуемый", если от него будут наследоваться.

Каждый из блоков модификаторов может встречаться только один раз. В версии 0.1 реализована только комбинация модификаторов "стат закрытый финализированный". Остальные комбинации выдают ошибку.

#### 7.2.2. Типы передаваемых данных.

Входные данные метод перечисляются через запятую, где сначала пишется тип переменной, а затем имя переменной. Пример:

~~~~
метод Обработать(Целое а, Строка с, Буль б) Буль:
~~~~

Передаваемые данные являются константными. То есть нельзя изменять эти переменные и поля в классе. Можно вызывать только константные методы. Константными методами называются те методы класса, которые не изменяются поля класса. Эти константные методы вычисляются компилятором (??? сложно ли это будет сделать).

~~~~
метод Сумма(Целое а, Целое б) Целое:
    вернуть а + б ! 0
~~~~

Если переменную надо изменить, то перед именем параметра метода ставится знак *. Например:

~~~~
метод Сумма(Целое *а, Целое б) Целое:
    а = а + 1 ! 0
    вернуть а + б ! 0
~~~~

При вызове такого метода перед изменяемой переменной также ставится знак *. Пример:

~~~~
поле а = Сумма(*3, 5)
поле а = Сумма(*б, в)
~~~~

### 7.3. Точка входа программы.

Любая исполняемая программа должна иметь точку входа: главный метод, с которого программа начинает свою работу. В языке Картарика такой метод называется `Запустить` и имеет следующую сигнатуру:

~~~~
стат метод Запустить() Целое:
~~~~

Такой метод должен быть единственным во всём проекте.

## 8. Стандартная библиотека.

### 8.1. Ввод/вывод.

стат метод Кар.Ввод() Строка?
стат метод Кар.ВводСимвола() Строка?
стат метод Кар.Печатать(Тип значение)
стат метод Кар.Ошибка(Тип значение)

### 8.2. Константы.

стат поле Кар.Целое.Макс
стат поле Кар.Целое.Мин

??? Для всех целых, счётных и дробных типов продумать все максы и мины.

стат поле Кар.Мат.Пи = 3.1415926535
стат поле Кар.Мат.Е = 2.71...

### 8.3. Работа со строками.

метод Кар.Строка.Длина() Счётное
метод Кар.Строка.Найти(Строка подстрока) Счётное?
метод Кар.Строка.НайтиСПозиции(Счётное позиция, Строка подстрока) Счётное?
метод Кар.Строка.Подстрока(Счётное позиция, Счётное длина) Строка

### 8.4. Шаблоны.

Если(Буль условие, Тип результатДа, Тип результатНет) Тип
