# Картарика. Стандарт языка программирования. Версия 0.1. (Черновик)

## Оглавление.

[1. Общие принципы.](#1)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[1.1. Лицензия.](#1.1)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[1.2. Описание документа.](#1.2)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[1.3. Пример кода.](#1.3)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[1.4. Общее описание языка.](#1.4)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[1.5. Общая структура проекта.](#1.5)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[1.6. Юникод и кодировка.](#1.6)

[2. Лексическая структура модуля.](#2)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[2.1. Грамматика.](#2.1)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[2.2. Конец строки.](#2.2)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[2.3. Комментарии.](#2.3)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[2.4. Пробелы.](#2.4)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[2.5. Ключевые слова.](#2.5)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[2.6. Идентификаторы.](#2.6)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[2.7. Литералы.](#2.7)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[2.7.1. Булевы значения.](#2.7.1)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[2.7.2. Целые числа.](#2.7.2)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[2.7.3. Цифра в шестнадцатеричном формате.](#2.7.3)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[2.7.4. Числа с плавающей точкой.](#2.7.4)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[2.7.5. Строковые литералы.](#2.7.5)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[2.7.6. Исключающие символы для строковых литералов.](#2.7.6)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[2.8. Разделители.](#2.8)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[2.9. Операторы.](#2.9)

[3. Логическая структура модуля.](#3)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[3.1. Строки модуля.](#3.1)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[3.2. Пустые строки модуля.](#3.2)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[3.3. Блоки.](#3.3)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[3.4. Пример.](#3.4)

[4. Типы данных.](#4)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[4.1. Простые типы данных](#4.1)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[4.1.1. Булевый тип.](#4.1.1)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[4.1.2. Целые числа.](#4.1.2)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[4.1.3. Числа с плавающей запятой.](#4.1.3)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[4.2. Ссылочные типы данных](#4.2)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[4.2.1. Строка.](#4.2.1)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[4.2.2. Неопределенность.](#4.2.2)

[5. Выражения.](#5)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.1. Простейшее выражение.](#5.1)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.2. Преобразование простых типов.](#5.2)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.2.1. Преобразование из булева числа в булево число.](#5.2.1)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.2.2. Преобразование из целого числа в булево число.](#5.2.2)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.2.3. Преобразование из счётного числа булево число.](#5.2.3)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.2.4. Преобразование из дробного числа булево число.](#5.2.4)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.2.5. Преобразование из строки в булево число.](#5.2.5)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.2.6. Преобразование из булева числа в целое число.](#5.2.6)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.2.7. Преобразование из целого числа в целое число.](#5.2.7)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.2.8. Преобразование из счётного числа в целое число.](#5.2.8)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.2.9. Преобразование из дробного числа в целое число.](#5.2.9)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.2.10. Преобразование из строки в целое число.](#5.2.10)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.2.11. Преобразование из булева числа в счётное число.](#5.2.11)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.2.12. Преобразование из целого числа в счётное число.](#5.2.12)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.2.13. Преобразование из счётного числа в счётное число.](#5.2.13)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.2.14. Преобразование из дробного числа в счётное число.](#5.2.14)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.2.15. Преобразование из строки в счётное число.](#5.2.15)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.2.16. Преобразование из булева числа в дробное число.](#5.2.16)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.2.17. Преобразование из целого числа в дробное число.](#5.2.17)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.2.18. Преобразование из счётного числа в дробное число.](#5.2.18)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.2.19. Преобразование из дробного числа в дробное число.](#5.2.19)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.2.20. Преобразование из строки в дробное число.](#5.2.20)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.2.21. Преобразование из булева числа в строку.](#5.2.21)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.2.22. Преобразование из целого числа в строку.](#5.2.22)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.2.23. Преобразование из счётного числа в строку.](#5.2.23)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.2.24. Преобразование из дробного числа в строку.](#5.2.24)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.2.25. Преобразование из строки в строку.](#5.2.25)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.3. Операция скобки (операция изменения приоритетов).](#5.3)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.4. Операция выбора элемента.](#5.4)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.5. Операция обращения к методу.](#5.5)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.6. Операция неопределённости.](#5.6)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.7. Операция определённости.](#5.7)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.8. Операция унарный плюс.](#5.8)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.9. Операция унарный минус.](#5.9)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.10. Операция сложения.](#5.10)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.11. Операция вычитания.](#5.11)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.12. Операция умножение.](#5.12)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.13. Операция деление.](#5.13)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.14. Операция защищённое деление.](#5.14)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.15. Операция остаток от деления.](#5.15)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.16. Операция защищённый остаток от деления.](#5.16)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.17. Операция побитовое И.](#5.17)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.18. Операция побитовое ИЛИ.](#5.18)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.19. Операция побитовое исключающее ИЛИ.](#5.19)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.20. Операция побитовое НЕ.](#5.20)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.21. Операция побитовый сдвиг вправо.](#5.21)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.22. Операция побитовый сдвиг влево.](#5.22)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.23. Операция проверка на равенство.](#5.23)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.24. Операция проверка на неравенство.](#5.24)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.25. Операция проверка больше.](#5.25)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.26. Операция проверка больше или равно.](#5.26)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.27. Операция проверка меньше.](#5.27)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.28. Операция проверка меньше или равно.](#5.28)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.29. Операция логическое И.](#5.29)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.30. Операция логическое ИЛИ.](#5.30)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.31. Операция логическое НЕ.](#5.31)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.32. Приоритет операций.](#5.32)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.33. Дополнительные уточнения по операциям.](#5.33)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.33.1. Числовые типы и литералы.](#5.33.1)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.33.2. Целочисленное деление и остаток для отрицательных чисел.](#5.33.2)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[5.33.3. Вычисление логических операций.](#5.33.3)

[6. Алгоритм.](#6)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[6.1. Общее описание.](#6.1)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[6.2. Вычисление выражения.](#6.2)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[6.3. Выход из алгоритма.](#6.3)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[6.4. Объявление переменной.](#6.4)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[6.5. Присваивание.](#6.5)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[6.6. Блок области видимости.](#6.6)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[6.7. Блок раскрытия неопределенности.](#6.7)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[6.8. Условный блок.](#6.8)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[6.9. Блок цикла по условию.](#6.9)

[7. Корневые элементы.](#7)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[7.1. Константы и переменные.](#7.1)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[7.1.1. Модификаторы поля.](#7.1.1)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[7.2. Методы (функции).](#7.2)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[7.2.1. Модификаторы метода.](#7.2.1)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[7.2.2. Типы передаваемых данных.](#7.2.2)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[7.3. Точка входа программы.](#7.3)

[8. Стандартная библиотека.](#8)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[8.1. Пакет Кар.Типы.](#8.1)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[8.1.1. Класс Кар.Типы.Буль.](#8.1.1)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[8.1.2. Класс Кар.Типы.Целое8.](#8.1.2)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[8.1.3. Класс Кар.Типы.Целое16.](#8.1.3)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[8.1.4. Класс Кар.Типы.Целое32.](#8.1.4)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[8.1.5. Класс Кар.Типы.Целое64.](#8.1.5)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[8.1.6. Класс Кар.Типы.Целое.](#8.1.6)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[8.1.7. Класс Кар.Типы.Счётное8.](#8.1.7)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[8.1.8. Класс Кар.Типы.Счётное16.](#8.1.8)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[8.1.9. Класс Кар.Типы.Счётное32.](#8.1.9)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[8.1.10. Класс Кар.Типы.Счётное64.](#8.1.10)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[8.1.11. Класс Кар.Типы.Счётное.](#8.1.11)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[8.1.12. Класс Кар.Типы.Дробное32.](#8.1.12)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[8.1.13. Класс Кар.Типы.Дробное64.](#8.1.13)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[8.1.14. Класс Кар.Типы.Дробное.](#8.1.14)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[8.1.15. Класс Кар.Типы.Строка.](#8.1.15)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[8.1.16. Шаблон класса Кар.Типы.Неопределённость.](#8.1.16)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[8.2. Пакет Кар.](#8.2)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[8.2.1. Класс Кар.Консоль.](#8.2.1)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[8.2.2. Класс Кар.ПотокОшибок.](#8.2.2)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[8.2.3. Класс Кар.Мат.](#8.2.3)

<a name=1></a>
## 1. Общие принципы.

<a name=1.1></a>
### 1.1. Лицензия.

Данный документ доступен под лицензией  Creative Commons Attribution 4.0 International. Ссылка на лицензию [https://creativecommons.org/licenses/by/4.0/deed.ru](https://creativecommons.org/licenses/by/4.0/deed.ru).

<a name=1.2></a>
### 1.2. Описание документа.

Настоящий документ определяет форму и устанавливает интерпретацию программ, выраженных на языке программирования Картарика. Его цель - способствовать единообразию, переносимости, надежности, удобству в обслуживании и эффективному выполнению программ на языке Картарика в различных вычислительных системах.

<a name=1.3></a>
### 1.3. Пример кода.

Вот пример простейшей программы, которая выводит на экран сообщение "Привет, мир!".

~~~~
стат метод Запустить() Целое:
	Консоль.Вывод("Привет, мир!\н")
	вернуть 0
~~~~

Данный текст программы должен быть записан в кодировке UTF-8 и помещен в файл с расширением "кар", например: ПриветМир.кар. Далее его можно откомпилировать с помощью программы:

~~~~
kar ПриветМир -o hello.exe
~~~~

и запустить из командной строки

~~~~
hello.exe
~~~~

После запуска программа выведен на экран строку "Привет, мир!".

<a name=1.4></a>
### 1.4. Общее описание языка.

Язык программирования Картарика или Картарский язык является строго-типизированным объектно-ориентированным языком с обязательной инициализацией переменных с ограниченным сборщиком мусора.
Он разработан так, чтобы быть достаточно простым, чтобы многие программисты могли свободно владеть этим языком.
Он задуман как производственный язык, а не альтернативный или исследовательский язык, и поэтому в дизайне по возможности не включаются новые и непроверенные функции.
Картарика вдохновлялся такими языками программирования, как C, C++, Java, C# и Python.

Язык программирования Картарика строго типизирован.
Для того, чтобы избежать неопределённости при работе с переменными, они обязательно должны быть инициализированы при объявлении.
В этом стандарте проводится различие между ошибками времени компиляции, которые могут и должны быть обнаружены во время компиляции, и теми, которые возникают во время выполнения.
Время компиляции обычно состоит из перевода программ в машинный код.
Действия во время выполнения включают загрузку и связывание классов, необходимых для выполнения программы, необязательную генерацию машинного кода и динамическую оптимизацию программы, а также фактическое выполнение программы.

Язык программирования Картарика является относительно высокоуровневым языком, поскольку детали машинного представления недоступны через этот язык.
Он включает в себя автоматическое управление хранилищем, обычно с использованием сборщика мусора, чтобы избежать проблем безопасности, связанных с явным освобождением (как free в C или delete в C++).

Язык не включает в себя никаких небезопасных конструкций, таких как доступ к массиву без проверки индекса, поскольку такие небезопасные конструкции могут привести к тому, что программа будет вести себя неопределенным образом.

<a name=1.5></a>
### 1.5. Общая структура проекта.

Файловая структура проекта. Проект состоит из одного файла. Результатом компиляции модуля является исполняемая программа.

В файле записывается непосредственно код программы.

В картарском языке модуль = файл = класс.

Файл модуля имеет расширение кар. Имя файла (без расширения) должен соответствовать правилам токена. Смотри  [2.6. Идентификаторы](#2.6).

Подробное описание синтаксиса модулей смотри в разделе [7. Корневые элементы](#7).

Если в одном модуле необходима ссылка на другой модуль, то он записывается в виде пути и имени файла (без расширения), разделенных точкой. В настоящее время модулем может быть модуль из стандартной библиотеки. Например, если модуль с именем `Модуль.кар` лежит в каталоге `Каталог1`, который в свою очередь лежит в каталоге `Каталог2`, то путь к модулю записывается так: `Каталог2.Каталог1.Модуль`.
Полное описание всех доступных функций и переменных смотри в разделе [8. Стандартная библиотека](#8).

<a name=1.6></a>
### 1.6. Юникод и кодировка.

Написанные программы используют ЮНИКОД версии 14.0 (UNICODE 14.0), описание которого можно найти на сайте

[http://www.unicode.org](http://www.unicode.org)

Используемая кодировка: UTF-8. Соответствующий стандарт находится здесь:

[https://tools.ietf.org/rfc/rfc3629.txt](https://tools.ietf.org/rfc/rfc3629.txt)

<a name=2></a>
## 2. Лексическая структура модуля.

<a name=2.1></a>
### 2.1. Грамматика.

Для описания грамматики используется расширенная форма Бэкуса-Наура, с некоторыми дополнениями.

Описание отдельных символов:

* Переменная, состоящая из одного символа, обозначает этот символ. Например: ф - русская буква ф, z - латинская буква z и т.д.
* Переменной "юникод" обозначается любой символ Юникода.
* Переменной "буква" обозначается любая буква любого алфавита Юникода.
* Символ Юникода также можно записать в виде \uHEX. То есть сначала записывается обратная косая черта, затем английская буква u и после неё номер символа в таблице Юникода в шестнадцатеричном формате. Например \u5F обозначает символ нижнего подчеркивания.

Правила записи расширенной формы Бэкуса-Наура, используемые в этом документе:

* Конкатенация. Конкатенируемые символы заключены в двойные кавычки. Правило вида A = "BCD". обозначает, что нетерминал A состоит из трех символов — B, C и D.
* Выбор. Обозначается вертикальной чертой. Правило вида A = B|C|D. Обозначает, что нетерминал A может состоять либо из B, либо из C, либо из D.
* Для сокращения записи выбора, если символы стоят рядом в таблице Юникод, можно обозначить промежуток символом тире. Правило вида 1-3. Обозначает либо 1, либо 2, либо 3.
* Кроме. Исключения в выборе обозначается восклицательным знаком. Правило 0-9!3!5 обозначает все цифры от 0 до 9, кроме 3 и 5. То есть 0, 1, 2, 4, 6, 7, 8, 9.
* Условное вхождение. Квадратные скобки выделяют необязательный элемент выражения, который может присутствовать, а может и отсутствовать. Правило вида A = [B]. обозначает, что нетерминал A либо является пустым, либо состоит из символа B.
* Повторение. Фигурные скобки обозначают конкатенацию любого числа (включая нуль) записанных в ней элементов. Правило вида A = {B}. обозначает, что A — либо пустой, либо представляет собой конкатенацию любого числа символов B (то есть A — это либо пустой элемент, либо B, либо BB, либо BBB и так далее). Если требуется, чтобы A представлял собой либо B, либо произвольное число B, но не мог быть пустым, используется запись A = B{B}.
* Круглые скобки. Они применяются для группировки элементов при формировании сложных выражений. Например, правило A = (B|C)(D|E). обозначает, что A состоит из двух символов, первым из которых является либо B, либо C, вторым — либо D, либо E, то есть A может быть одной из цепочек BD, BE, CD, CE.

<a name=2.2></a>
### 2.2. Конец строки.

Грамматическое описание конца строки:

~~~~
СимволПереводаСтроки = \u0A
СимволВозвратаКаретки = \u0D
КонецСтроки = [СимволВозвратаКаретки] СимволПереводаСтроки
~~~~

Конец строки может быть либо символом перевода строки либо сочетанием символов возврата каретки и перевода строки ("\n" или "\r\n" в обозначении языков с С-подобным синтаксисом).

<a name=2.3></a>
### 2.3. Комментарии.

Комментарии могут быть однострочными и многострочными.

Грамматическое описание однострочного комментария:

~~~~
ОднострочныйКомментарий = "//" {Юникод!КонецСтроки}
~~~~

Перед началом однострочного комментария ставится удвоенный символ "/" после чего идёт любая последовательность символов до символов конца строки. Символ конца строки не считается частью комментария.

Грамматическое описание многострочного комментария:

~~~~
МногострочныйКомментарий = "/*" {Юникод!"*/"} "*/"
~~~~

Многострочный комментарий заключен в символы "/*" и "*/" внутри которого может быть любая комбинация текстовых символов за исключением последовательности "*/".

Комментарий можно поставить в любое место, где можно поставить пробельный символ.

<a name=2.4></a>
### 2.4. Пробелы.

Грамматическое описание пробельных символов:
~~~~
СимволПробела = \u20
СимволТабуляции = \u09
ПробельныйСимвол = СимволПробела | СимволТабуляции | Комментарий
Пробел = ПробельныйСимвол{ПробельныйСимвол}
~~~~

Пробел состоит из одного или более пробельных символов. Пробельным символом является символ пробела, символ горизонтальной табуляции или комментарий.

В начале строки Пробел выполняет также дополнительную функцию определения к какому блоку принадлежит строка (смотри главу [3.3. Блоки](#3.3)). Один символ горизонтальной табуляции является табуляцией длиной в четыре пробела, комментарий - пробельный символ длиной в ноль пробелов.

<a name=2.5></a>
### 2.5. Ключевые слова.

Грамматическое описание списка ключевых слов представлено ниже:

~~~~
ЗначениеДа = "Да"
ЗначениеНет = "Нет"
ЗначениеБесконечность = "Бесконечность"
ЗначениеПлюсБесконечность = "ПлюсБесконечность"
ЗначениеМинусБесконечность = "МинусБесконечность"
ЗначениеНеЧисло = "НеЧисло"
ЗначениеПусто = "Пусто"

ТипБуль = "Буль"
ТипЦелое8 = "Целое8"
ТипЦелое16 = "Целое16"
ТипЦелое32 = "Целое32"
ТипЦелое64 = "Целое64"
ТипЦелое = "Целое"
ТипСчётное8 = "Счётное8"
ТипСчётное16 = "Счётное16"
ТипСчётное32 = "Счётное32"
ТипСчётное64 = "Счётное64"
ТипСчётное = "Счётное"
ТипДробное32 = "Дробное32"
ТипДробное64 = "Дробное64"
ТипДробное = "Дробное"
ТипСтрока = "Строка"

ОпСравненияБольше = "бш"
ОпСравненияБольшеИлиРавно = "бир"
ОпСравненияМеньше = "мш"
ОпСравненияМеньшеИлиРавно = "мир"
ОпЛогическоеИ = "и"
ОпЛогическоеИли = "или"
ОпЛогическоеНе = "не"
ОпПобитовоеИ = "би"
ОпПобитовоеИли = "били"
ОпПобитовоеИсключающееИли = "билине"
ОпПобитовоеНе = "бне"
ОпБитыВправо = "вправо"
ОпБитыВлево = "влево"

АлгоритмВернуть = "вернуть"
АлгоритмБлок = "блок"
АлгоритмПропустить = "пропустить"
АлгоритмРаскрыть = "раскрыть"
АлгоритмКак = "как"
АлгоритмЕсли = "если"
АлгоритмИначе = "иначе"
АлгоритмПока = "пока"
АлгоритмПрервать = "прервать"
АлгоритмСледующий = "следующий"

ОбъявлениеПоля = "поле"
ОбъявлениеКонстанты = "конст"
ОбъявлениеМетода = "метод"

МодификаторСтат = "стат"
МодификаторДинамическое = "динамическое"
МодификаторЗакрытое = "закрытое"
МодификаторЗащищённое = "защищённое"
МодификаторОткрытое = "открытое"
МодификаторДинамический = "динамический"
МодификаторЗакрытый = "закрытый"
МодификаторЗащищённый = "защищённый"
МодификаторОткрытый = "открытый"
МодификаторФинализируемый = "финализируемый"
МодификаторНаследуемый = "наследуемый"
МодификаторПерегруженный = "перегруженный"

КлючевоеСлово =
    ЗначениеДа | ЗначениеНет | ЗначениеБесконечность |
    ЗначениеПлюсБесконечность | ЗначениеМинусБесконечность |
    ЗначениеНеЧисло | ЗначениеПусто | ТипБуль | ТипЦелое8 |
    ТипЦелое16 | ТипЦелое32 | ТипЦелое64 | ТипЦелое | ТипСчётное8 |
    ТипСчётное16 | ТипСчётное32 | ТипСчётное64 | ТипСчётное |
    ТипДробное32 | ТипДробное64 | ТипДробное | ТипСтрока |
    ОпСравненияБольше | ОпСравненияБольшеИлиРавно |
    ОпСравненияМеньше | ОпСравненияМеньшеИлиРавно | ОпЛогическоеИ |
    ОпЛогическоеИли | ОпЛогическоеНе | ОпПобитовоеИ | ОпПобитовоеИли |
    ОпПобитовоеИсключающееИли | ОпПобитовоеНе | ОпБитыВправо |
    ОпБитыВлево | АлгоритмБлок | АлгоритмВернуть |
    АлгоритмПропустить | АлгоритмРаскрыть | АлгоритмКак |
    АлгоритмЕсли | АлгоритмИначе | АлгоритмПока | АлгоритмПрервать |
    АлгоритмСледующий | ОбъявлениеПоля | ОбъявлениеКонстанты |
    ОбъявлениеМетода | МодификаторСтат | МодификаторДинамическое |
    МодификаторЗакрытое | МодификаторЗащищённое |
    МодификаторОткрытое | МодификаторДинамический |
    МодификаторЗакрытый | МодификаторЗащищённый |
    МодификаторОткрытый | МодификаторФинализируемый |
    МодификаторНаследуемый | МодификаторПерегруженный
~~~~

Значение этих ключевых слов раскрывается ниже в следующих главах данного стандарта.

<a name=2.6></a>
### 2.6. Идентификаторы.

Идентификатором называется последовательность букв, цифр и символа подчёркивания. Идентификатор не может начинаться с цифры. Кроме того, буквы в одном и том же идентификаторе должны быть из одного и того же алфавита Unicode.

С учётом вышеописанных условий, грамматическое описание идентификатора будет выглядеть так:

~~~~
СимволПодчёркивания = \u5F
Цифра = 0-9

БукваАрмянскогоАлфавита = \u0531-\u0556 | \u0559-\u058A | \u058D-\u058F
БукваКарийскогоАлфавита = \u102A0-\u102D0
...

ИдентификаторАрмянскогоАлфавита =
    (БукваАрмянскогоАлфавита | СимволПодчёркивания)
    {БукваАрмянскогоАлфавита | СимволПодчёркивания | Цифра}
ИдентификаторКарийскогоАлфавита =
    (БукваКарийскогоАлфавита | СимволПодчёркивания)
    {БукваКарийскогоАлфавита | СимволПодчёркивания | Цифра}
...

Идентификатор =
    (ИдентификаторАрмянскогоАлфавита |
    ИдентификаторКарийскогоАлфавита |
    ...)
    !КлючевоеСлово
~~~~

Здесь не описан полный список алфавитов, иначе формула будет слишком длинной и, кроме того, описание различных символов относится к области действия Unicode.

<a name=2.7></a>
### 2.7. Литералы.

<a name=2.7.1></a>
#### 2.7.1. Булевы значения.

Грамматическое описание:

~~~~
БулевоЗначение = ЗначениеДа | ЗначениеНет
~~~~

Булево значение может принимать одно из двух значений "Да" или "Нет", соответствующие булевым значениям "Правда" и "Ложь" соответственно.

<a name=2.7.2></a>
#### 2.7.2. Целые числа.

Грамматическое описание:

~~~~
Знак = + | -
ЦелоеЧисло = [Знак] Цифра{Цифра}
~~~~

В начале целого числа может стоять знак "+" или "-". Далее идет набор цифр от 0 до 9.

<a name=2.7.3></a>
#### 2.7.3. Цифра в шестнадцатеричном формате.

Грамматическое описание:

~~~~
ШестнадцатеричнаяЦифра =
    0-9 | а | А | б | Б | в | В | г | Г | д | Д | е | Е
ШестнадцатеричноеЧисло =
    "0ш" ШестнадцатеричнаяЦифра{ШестнадцатеричнаяЦифра}
~~~~

Шестнадцатеричное число начинается с символов 0ш а затем идут одна или несколько шестнадцатеричных цифр: от нуля до девяти и далее A=10, Б=11, В=12, Г=13, Д=14, Е=15. Буквы могут быть как заглавные, так и маленькие.

<a name=2.7.4></a>
#### 2.7.4. Числа с плавающей точкой.

Грамматическое описание:

~~~~
Точка = \u2E
Знак = + | -
ОбычнаяЗаписьДробного = [Знак] Цифра{Цифра} Точка Цифра{Цифра}

Экспонента = "с" | "С"
ЭкспоненциальнаяЗаписьДробного =
    (ЦелоеЧисло | ОбычнаяЗаписьДробного) Экспонента ЦелоеЧисло

ДробноеЧисло =
    ЗначениеНеЧисло | ЗначениеБесконечность |
    ЗначениеПлюсБесконечность | ЗначениеМинусБесконечность |
    ОбычнаяЗаписьДробного | ЭкспоненциальнаяЗаписьДробного
~~~~

Существует два основных типа записи чисел с плавающей точкой: обычная запись и экспоненциальная запись.

В обычной записи числа с плавающей точкой в начале может стоять знак "+" или "-". Далее идет набор цифр от 0 до 9, обозначающий целую часть числа, затем символ ".", затем цифры от 0 до 9, обозначающие дробную часть числа.

В экспоненциальной записи сначала идет мантисса, которая записывается как обычная запись числа или целое число, затем символ "с" или "С" разделяющее мантиссу и экспоненту, затем целое число, обозначающее экспоненту.

Кроме того, для особых значений чисел с плавающей точкой применяются ключевые слова "НеЧисло", "Бесконечность", "ПлюсБесконечность" и "МинусБесконечность".

Примечание. Знак, разделяющий мантиссу и экспоненту взяли "с" вместо "э", так как символ "э" находится с краю клавиатуры, поэтому "с" будет удобнее для набора. Под "с" имеется в виду слово "степень".

<a name=2.7.5></a>
#### 2.7.5. Строковые литералы.

Грамматическое описание:

~~~~
СимволДвойныхКавычек = \u22
СимволИсключения = \u5C
СтрочныйСимвол = Юникод!СимволДвойныхКавычек!СимволИсключения
Строка =
    СимволДвойныхКавычек
    {СтрочныйСимвол | ИсключающиеСимволы}
    СимволДвойныхКавычек
~~~~

Двойные кавычки используются для обозначения строкового литерала. Внутри могут стоять любые символы кроме символа двойной кавычки и символа исключения. Символ исключения используется для создания исключающих символов, описанных в главе [2.7.6. Исключающие символы для строковых литералов](#2.7.6).

<a name=2.7.6></a>
#### 2.7.6. Исключающие символы для строковых литералов.

Грамматическое описание:

~~~~
ИсключающийСимволВозвратаКаретки = СимволИсключения к
ИсключающийСимволНовойСтроки = СимволИсключения н
ИсключающийСимволГоризонтальнойТабуляции = СимволИсключения т
ИсключающийСимволДвойныхКавычек = СимволИсключения ДвойныеКавычки
ИсключающийСимволОбратногоСлеша = СимволИсключения СимволИсключения

ИсключающийСимволЮникод =
    СимволИсключения ш
    ШестнадцатеричнаяЦифра{ШестнадцатеричнаяЦифра}
    [СимволПробела]

ИсключающиеСимволы =
    ИсключающийСимволВозвратаКаретки | ИсключающийСимволНовойСтроки |
    ИсключающийСимволГоризонтальнойТабуляции |
    ИсключающийСимволДвойныхКавычек | ИсключающийСимволОбратногоСлеша |
    ИсключающийСимволЮникод
~~~~

В строке можно записать символ возврата каретки, символ новой строки или символ табуляции, напрямую написав их внутри строки или добавив сочетание символов "\к", "\н" или "\т" соответственно. Если необходимо добавить двойные кавычки внутри строки, необходимо добавить в строку сочетание "\"". Для добавления обратного слеша, необходимо просто его удвоить: "\\".

Также можно добавить юникод-символы, записав их шестнадцатеричные коды с помощью исключающего символа "\ш". Сначала пишется ключевое буквосочетание "\ш", затем пишутся шестнадцатеричный код символа. Можно написать сразу несколько кодов, для этого их надо писать через запятую. По окончании записи юникод-символов ставится пробел, либо любой другой символ, не использующийся в написании шестнадцатеричного символа. Если в конце шестнадцатеричных символов ставится пробел, то он съедается.

Пример:

~~~~
"Маленькая греческая буква альфа \ш3Б1"
"Маленькие греческие буквы альфа и бетта \ш3Б1,3Б2 22"
~~~~

Конечное преобразование этих строк будет таким:

~~~~
"Маленькая греческая буква альфа α"
"Маленькие греческие буквы альфа и бетта αβ22"
~~~~

Обратите внимание, что в конце второй строки перед символами "22" стоит пробел. Он обозначает конец исключающего символа "\ш" и как бы "съедается".

<a name=2.8></a>
#### 2.8. Разделители.

Грамматическое описание:

~~~~
ОткрывающаясяСкобка = \u28
ЗакрывающаясяСкобка = \u29
Запятая = \u2C
~~~~

Разделители используются в разных случаях в выражениях, алгоритмах и модулях. Подробное предназначение описывается в главах ниже.

<a name=2.9></a>
#### 2.9. Операторы.

Следующие токены являются операторами:

~~~~
СимволПлюс = \u2B
СимволМинус = \u2D
СимволУмножить = \u2A
СимволРазделить = \u2F
СимволОстаток = \u25
СимволПрисвоение = \u3D
СимволТочка = \u2E
СимволДвоеточие= \u3A
СимволНеопределённость = \u3F
СимволОпределённость = \u21

ОпРазделитьЗащищённо = \u2F\u21
ОпОстатокЗащищённо = \u25\u21
ОпСравненияРавно = "=="
ОпСравненияНеРавно = "не="
~~~~

Также операторами являются следующие ключевые слова, определённые в главе [2.5. Ключевые слова](#2.5).

~~~~
ОпСравненияБольше
ОпСравненияБольшеИлиРавно
ОпСравненияМеньше
ОпСравненияМеньшеИлиРавно

ОпЛогическоеИ
ОпЛогическоеИли
ОпЛогическоеНе

ОпПобитовоеИ
ОпПобитовоеИли
ОпПобитовоеИсключающееИли
ОпПобитовоеНе
ОпБитыВправо
ОпБитыВлево
~~~~

Подробное описание значений этих токенов описаны в разделе [5. Выражения](#5).

<a name=3></a>
## 3. Логическая структура модуля.

<a name=3.1></a>
### 3.1. Строки модуля.

Фактически модуль разбивается на строки. Понятие строки модуля и строки текстового файла близки, но всё же различаются.

Разница состоит в следующем. В текстовом файле разделение на строки всегда происходит с помощью текстового разделения на строки (грамматически описывается через переменную `КонецСтроки`). При разбиении модуля на строки, символ новой строки может игнорироваться в следующих случаях:

1. Если символ новой строки находится в комментарии, он игнорируется при разбиении модуля на строки.

2. Внутри круглых скобок символ новой строки игнорируется.

3. Внутри двойных кавычек символ новой строки интерпретируется как часть строковой константы.

Поэтому существует 3 способа разбить строку модуля на несколько строк текстового файла:

1 способ. Комментарий сильнее символа новой строки. Это означает, что в любом месте, где разрешен пробельный символ можно с помощью комментария разделить одну строку на две. Например:

~~~~
поле Количество = /*

*/ 5
~~~~

2 способ. Скобки сильнее символа новой строки. Это означает, что внутри любой круглой скобки, везде, где разрешен пробельный символ можно добавить символ новой строки:

~~~~
стат метод ПосчитатьСумму(
    Целое Слагаемое1,
    Целое Слагаемое2
) Целое:
~~~~

3 способ. Внутри строкового токена можно добавить символ новой строки вместо исключающих символов.

~~~~
    поле ПриветМир = "Привет, мир!!!
Привет, мир!!!
Привет, мир!!!"
~~~~

<a name=3.2></a>
### 3.2. Пустые строки модуля.

После разделения модуля на строки, пустые строки игнорируются. Пустые строки это строки модуля, которые состоят только из пробельных символов (то есть символов пробела, табуляции и комментариев). Формально пустую строку можно описать следующим образом:

~~~~
ПустаяСтрока = {ПробельныйСимвол} КонецСтроки
~~~~

<a name=3.3></a>
### 3.3. Блоки.

Когда пустые строки удалены, все остальные строки объединяются в блоки по иерархической структуре.

Блок состоит из заголовка блока и следующего за ним тела блока. Заголовком блока, является непустая строка, описывающая блок. Тело блока - это несколько подряд идущих строк, которые имеют один и тот же размер отступа. Кроме того, размер отступа тела блока всегда больше, чем размер заголовка блока. Кроме того, сам блок может быть частью блока более верхнего уровня.

Грамматическое описание блока можно представить так:

~~~~

ОтступВерхнегоУровня = {ПробельныйСимвол}
ОтступБлока = ПробельныйСимвол{ПробельныйСимвол}

СтрокаЗаголовкаБлока =
    ОтступВерхнегоУровня ЗаголовокБлока
    {ПробельныйСимвол} СимволДвоеточие {ПробельныйСимвол} НоваяСтрока
СтрокаБлока =
    ОтступВерхнегоУровня* ОтступБлока* Алгоритм

НепустойБлок = СтрокаЗаголовкаБлока СтрокаБлока {СтрокаБлока}
~~~~

* - отступ применяется для каждой строки алгоритма.

Отступы состоят из пробелов и табуляций. Один символ табуляции эквивалентен 4 символам пробела. Отступ блока может состоять из любого ненулевого количества пробелов.

Если у заголовка блока размер отступа равен 0 символов, это значит что он не имеет родительского блока и называется корневым блоком или корневым элементом модуля. Описание корневых блоков находится в разделе [7. Корневые элементы](#7). Описание некорневых блоков можно найти в разделе [6. Алгоритм](#6).

Существует также вырожденный случай, когда блок может быть пустым. В этом случае он оформляется следующим образом:

~~~~
СтрокаПустогоБлока =
    ОтступВерхнегоУровня ОтступБлока
    АлгоритмПропустить {ПробельныйСимвол} НоваяСтрока

ПустойБлок = СтрокаЗаголовкаБлока СтрокаПустогоБлока

Блок = ПустойБлок | НепустойБлок
~~~~

То есть тело блока должно состоять из одной непустой строки модуля, с ключевым словом "пропустить".

<a name=3.4></a>
### 3.4. Пример.

Пример программы:

~~~~
стат конст Пи = 3.1415926535897932

стат метод Запустить() Целое:
    поле Радиус = 0.0

    пока Радиус мш 10.0:
        Радиус = Радиус + 1.0
        Консоль.Вывод("Если радиус = ")
        Консоль.Вывод(Радиус)
        Консоль.Вывод(", то длина окружности = ")
        Консоль.Вывод(2 * Пи * Радиус)

    если Радиус мш 10.0:
      пропустить

	вернуть 0

~~~~

В данном примере программа вычисляет длину окружности для соответствующего ему радиуса в значении от 1 до 10 с шагом 1. В примере мы видим 2 корневых блока: константа Пи и метод Запустить. В методе есть различные дочерние команды и блоки: объявление поля Радиус, блок "пока", блок "если" и команда выхода из метода. В блоках есть свои дочерние команды. Кроме того, блок "если" здесь является пустым. Обратите также внимание, что размеры отступов в блоке "пока" и в блоке "если" отличаются.

<a name=4></a>
## 4. Типы данных.

Картарский язык программирования - это строго типизированный язык. Это означает, что каждая переменная и выражение имеет свой тип, известный на этапе компиляции.

<a name=4.1></a>
### 4.1. Простые типы данных

Простые типы данных делятся на беззнаковые целые, знаковые целые, числа с плавающей точкой и булевы числа.

<a name=4.1.1></a>
#### 4.1.1. Булевый тип.

Булевый тип:

* Буль - булево число, принимающее одно из двух значений: "Да" или "Нет".

<a name=4.1.2></a>
#### 4.1.2. Целые числа.

Ряд типов для знаковых целых чисел:

* Целое8 - 8-ми битное знаковое целое число. Принимает целочисленные значения от -128 до 127 включительно.
* Целое16 - 16-ти битное знаковое целое число. Принимает целочисленные значения от -32768 до 32767 включительно.
* Целое32 - 32-ти битное знаковое целое число. Принимает целочисленные значения от -2147483648 до 2147483647 включительно.
* Целое64 - 64-ти битное знаковое целое число. Принимает целочисленные значения от -9223372036854775808 до 9223372036854775807 включительно.
* Целое - синоним для типа Целое32.

Ряд типов для беззнаковых целых чисел:

* Счётное8 - 8-ми битное беззнаковое целое число. Принимает целочисленные значения от 0 до 255 включительно.
* Счётное16 - 16-ми битное беззнаковое целое число. Принимает целочисленные значения от 0 до 65535 включительно.
* Счётное32 - 32-ми битное беззнаковое целое число. Принимает целочисленные значения от 0 до 4294967295 включительно.
* Счётное64 - 64-ми битное беззнаковое целое число. Принимает целочисленные значения от 0 до 18446744073709551615 включительно.
* Счётное - синоним для типа Счётное32.

<a name=4.1.3></a>
#### 4.1.3. Числа с плавающей запятой.

Ряд типов для чисел с плавающей запятой:

* Дробное32 - числа с плавающей точкой одинарной точности (single precision) согласно стандарту IEEE Standard for Binary Floating-Point Arithmetic, ANSI/IEEE Standard 754-1985 (IEEE, New York).
* Дробное64 - числа с плавающей точкой двойной точности (double precision) согласно стандарту IEEE Standard for Binary Floating-Point Arithmetic, ANSI/IEEE Standard 754-1985 (IEEE, New York).
* Дробное - синоним для типа Дробное64.

<a name=4.2></a>
### 4.2. Ссылочные типы данных

<a name=4.2.1></a>
#### 4.2.1. Строка.

Экземпляр класса "Строка" представляет набор символов Юникод. Строковый объект имеет константное (неизменяемое) значение. Строковые литералы ссылаются на экземпляры класса "Строка".

<a name=4.2.2></a>
#### 4.2.2. Неопределенность.

Неопределенность - это тип данных, который модифицирует основной тип данных. Тип неопределенность может принимать либо специальное значение "Пусто", либо значение основного типа.

~~~~
поле Количество = Целое?(Пусто)
поле Цена = Целое?(35)
~~~~

Перевод из неопределенного типа в соответствующий ему определенный можно совершить с помощью помощью блока "раскрыть", описанного в главе [6.7. Блок раскрытия неопределенности](#6.7). Пример:

~~~~
поле Количество = Целое?(Пусто)

Консоль.Вывод(Количество.или(-1))

раскрыть Количество как Кол:
    Консоль.Вывод(Кол)
иначе:
    Консоль.Вывод("Количество не определено")
~~~~

<a name=5></a>
## 5. Выражения.

<a name=5.1></a>
### 5.1. Простейшее выражение.

Грамматическое описание:

~~~~
Выражение =
    Идентификатор | БулевоЗначение | ЦелоеЧисло | ШестнадцатеричноеЧисло |
    ДробноеЧисло | Строка
~~~~

Простейшим выражением является имя переменной, либо имя константы, либо булевый, цифровой или строковый литерал.

Выходной тип выражения в зависимости от входного:

- если входным типом является БулевоЗначение, то выходной - Буль.
- если входным типом является Идентификатор, то выходной тип является тем же, что и тип входного идентификатора.
- если входным типом является ЦелоеЧисло, то выходной - Целое.
- если входным типом является ШестнадцатеричноеЧисло, то выходной - Счётное.
- если входным типом является ДробноеЧисло, то выходной - Дробное.
- если входным типом является Строка, то выходной - Строка.

Примеры простейшего выражения:

~~~~
Нет
Кар
3
3.5
"Привет, мир!!!"
~~~~

<a name=5.2></a>
### 5.2. Преобразование простых типов.

Все преобразования являются явными. Неявные преобразования запрещены.

Общий вид методов преобразования из типа Тип1 в тип Тип2 имеют один из следующих видов:

~~~~
открытый стат метод Тип2(Тип1 значение) Тип2
открытый стат метод Тип2(Тип1 значение) Тип2?
~~~~

Эта группа методов преобразует один простейший тип в другой. Возвращаемым значением может быть либо выходной тип, либо неопределенность выходного типа. Неопределенность появляется в преобразованиях между теми типами, которые не всегда могут быть однозначно преобразованы.

Пример преобразования типа Строка в тип Целое:

~~~~
поле А = "45"
поле Б = Целое(А) // Б = Целое?(45)
~~~~

<a name=5.2.1></a>
#### 5.2.1. Преобразование из булева числа в булево число.

Общая формула преобразования:

~~~~
метод Буль(Буль буль) Буль
~~~~

Фактически это копирование булевого значения.

Примеры преобразования:

~~~~
поле А = Буль(Нет) // А = Нет
поле Б = Буль(Да) // Б = Да
~~~~

<a name=5.2.2></a>
#### 5.2.2. Преобразование из целого числа в булево число.

Общая формула преобразования:

~~~~
метод Буль(ЦелоеМ целое) Буль?
~~~~

где буква М обозначает одно из чисел: 8, 16, 32, 64, или пустое значение.

Если целое число равно 0, то оно преобразуется в булево значение "Нет". Если целое число равно 1, то оно преобразуется в булево значение "Да". В остальных случаях функция выдает значение Пусто.

Пример преобразования типа Целое в тип Буль:

~~~~
поле А = -1
поле Б = Буль(А) // Б = Буль?(Пусто)

поле В = 1
поле Г = Буль(В) // В = Буль?(Да)
~~~~

<a name=5.2.3></a>
#### 5.2.3. Преобразование из счётного числа булево число.

Общая формула преобразования:

~~~~
метод Буль(СчётноеМ счётное) Буль?
~~~~

где буква М обозначает одно из чисел: 8, 16, 32, 64, или пустое значение.

Если счётное число равно 0, то оно преобразуется в булево значение "Нет". Если счётное число равно 1, то оно преобразуется в булево значение "Да". В остальных случаях функция выдает значение Пусто.

Примеры преобразования:

~~~~
поле А = Счётное(25)
поле Б = Буль(А) // Б = Буль?(Пусто)

поле В = Счётное(1)
поле Г = Буль(В) // В = Буль?(Да)
~~~~

<a name=5.2.4></a>
#### 5.2.4. Преобразование из дробного числа булево число.

Общая формула преобразования:

~~~~
метод Буль(ДробноеМ дробное) Буль?
~~~~

где буква М обозначает одно из чисел 32, 64, или пустое значение.

Если дробное число равно 0.0, то оно преобразуется в булево значение "Нет". Если дробное число равно 1.0, то оно преобразуется в булево значение "Да". В остальных случаях функция выдает значение Пусто.

Примеры преобразования:

~~~~
поле А = 256.5
поле Б = Буль(А) // Б = Буль?(Пусто)

поле В = 1.0
поле Г = Буль(В) // Г = Буль?(Да)
~~~~

<a name=5.2.5></a>
#### 5.2.5. Преобразование из строки в булево число.

Общая формула преобразования:

~~~~
метод Буль(Строка строка) Буль?
~~~~

Строка "Да" преобразуется в значение Да, строка "Нет" преобразуется в значение Нет. При этом каждая буква может быть записана в любом регистре. В остальных случаях функция возвращает значение Пусто.

Примеры преобразования:

~~~~
поле А = "дА"
поле Б = Буль(А) // Б = Буль?(Да)
поле В = Буль("Y") // В = Буль?(Пусто)
~~~~

<a name=5.2.6></a>
#### 5.2.6. Преобразование из булева числа в целое число.

Общая формула преобразования:

~~~~
метод ЦелоеН(Буль буль) ЦелоеН
~~~~

где буква Н обозначает одно из чисел: 8, 16, 32, 64, или пустое значение.

Значение "Нет" преобразуется в число 0, значение "Да" преобразуется в число 1 для любого типа из линейки целых чисел.

Примеры преобразования:

~~~~
поле А = Целое(Нет) // А = 0
поле Б = Целое8(Да) // Б = 1
~~~~

<a name=5.2.7></a>
#### 5.2.7. Преобразование из целого числа в целое число.

Общая формула преобразования:

~~~~
метод ЦелоеН(ЦелоеМ целое) ЦелоеН
~~~~

где буква М и Н обозначают одно из чисел: 8, 16, 32, 64, или пустое значение.

При преобразовании из меньшего в большее по разрядности число, старшие биты заполняются знаковым битом, то есть 0 для положительных чисел и 1 для отрицательных. При преобразовании из большего в меньшее по разрядности число, старшие разряды просто удаляются.

Пример преобразования типа Целое в тип Целое8:

~~~~
поле А = 255
поле Б = Целое8(А) // Б = -1
поле В = Целое(Б) // В = -1
~~~~

<a name=5.2.8></a>
#### 5.2.8. Преобразование из счётного числа в целое число.

Общая формула преобразования:

~~~~
метод ЦелоеН(СчётноеМ счётное) ЦелоеН
~~~~

где буква М и Н обозначают одно из чисел: 8, 16, 32, 64 или пустое значение.

При преобразовании из меньшего в большее по разрядности число, старшие биты заполняются 0. При преобразовании из большего в меньшее по разрядности число, старшие разряды просто удаляются.

Примеры преобразования:

~~~~
поле А = Счётное(255)
поле Б = Целое8(А) // Б = -1
поле В = Целое16(А) // В = 255
~~~~

<a name=5.2.9></a>
#### 5.2.9. Преобразование из дробного числа в целое число.

Общая формула преобразования:

~~~~
метод ЦелоеН(ДробноеМ дробное) ЦелоеН?
~~~~

где буква М обозначает одно из чисел 32, 64, или пустое значение, а буква Н обозначает одно из чисел: 8, 16, 32, 64, или пустое значение.

Если число с плавающей точкой преобразуется в целое, то дробная часть отбрасывается (округление в сторону 0). Если значение целой части не может быть представлено целым типом (слишком большое значение дробного числа, либо дробное имеет значение Бесконечность/ПлюсБесконечность/МинусБесконечность, либо дробное имеет значение НеЧисло), то результат — не определён.

Примеры преобразования:

~~~~
поле А = Дробное(255.5)
поле Б = Целое8(А) // Б = Целое8?(Пусто)
поле В = Целое16(А) // В = Целое16?(255)
~~~~

<a name=5.2.10></a>
#### 5.2.10. Преобразование из строки в целое число.

Общая формула преобразования:

~~~~
метод ЦелоеН(Строка строка) ЦелоеН?
~~~~

где буква Н обозначает одно из чисел: 8, 16, 32, 64, или пустое значение.

Если строка представляет собой последовательность символов, как у литерала целого (смотри главу [2.7.1. Целые числа](#2.7.1)) или шестнадцатеричного числа (смотри главу [2.7.2. Цифра в шестнадцатеричном формате](#2.7.2)), то такая строка преобразуется в Целое число. В ином случае функция преобразования возвращает значение Пусто. Если значение числа записанное в строке не может вместиться в размер числа, то результатом преобразования также будет значение Пусто.

Примеры преобразования:

~~~~
поле строка1 = "123"
поле число1 = Целое(строка1) // число1 = Целое?(123)

поле строка2 = "-123"
поле число2 = Целое(строка2) // число2 = Целое?(-123)

поле строка3 = "123.1"
поле число3 = Целое(строка3) // число3 = Целое?(Пусто)
~~~~

<a name=5.2.11></a>
#### 5.2.11. Преобразование из булева числа в счётное число.

Общая формула преобразования:

~~~~
метод СчётноеН(Буль буль) СчётноеН
~~~~

где буква Н обозначает одно из чисел: 8, 16, 32, 64, или пустое значение.

Значение "Нет" преобразуется в число 0, значение "Да" преобразуется в число 1 для любого типа из линейки счётных чисел.

Примеры преобразования:

~~~~
поле А = Счётное(Нет) // А = 0
поле Б = Счётное8(Да) // Б = 1
~~~~

<a name=5.2.12></a>
#### 5.2.12. Преобразование из целого числа в счётное число.

Общая формула преобразования:

~~~~
метод СчётноеН(ЦелоеМ целое) СчётноеН
~~~~

где буква М и Н обозначают одно из чисел: 8, 16, 32, 64, или пустое значение.

При преобразовании из меньшего в большее по разрядности число, старшие биты заполняются знаковым битом, то есть 0 для положительных чисел и 1 для отрицательных. При преобразовании из большего меньшее по разрядности число, старшие разряды просто удаляются.

Пример преобразования типа Целое в тип Счётное8:

~~~~
поле А = -1
поле Б = Счётное8(А) // Б = 255
~~~~

<a name=5.2.13></a>
#### 5.2.13. Преобразование из счётного числа в счётное число.

Общая формула преобразования:

~~~~
метод СчётноеН(СчётноеМ счётное) СчётноеН
~~~~

где буква М и Н обозначают одно из чисел: 8, 16, 32, 64, или пустое значение.

При преобразовании из меньшего в большее по разрядности число, старшие биты заполняются 0. При преобразовании из большего меньшее по разрядности число, старшие разряды просто удаляются.

Примеры преобразования:

~~~~
поле А = Счётное(256)
поле Б = Счётное8(А) // Б = 0
поле В = Счётное16(А) // В = 256
~~~~

<a name=5.2.14></a>
#### 5.2.14. Преобразование из дробного числа в счётное число.

Общая формула преобразования:

~~~~
метод СчётноеН(ДробноеМ дробное) СчётноеН?
~~~~

где буква М обозначает одно из чисел 32, 64, или пустое значение, а буква Н обозначает одно из чисел: 8, 16, 32, 64, или пустое значение.

Если число с плавающей точкой преобразуется в счётное, то дробная часть отбрасывается (округление в сторону 0). Если значение целой части не может быть представлено счётным типом (слишком большое значение дробного числа, либо отрицательное число, либо дробное имеет значение Бесконечность/ПлюсБесконечность/МинусБесконечность, либо дробное имеет значение НеЧисло), то результат не определён.

Примеры преобразования:

~~~~
поле А = Дробное(256.5)
поле Б = Счётное8(А) // Б = Счётное8?(Пусто)
поле В = Счётное16(А) // В = Целое16?(255)
~~~~

<a name=5.2.15></a>
#### 5.2.15. Преобразование из строки в счётное число.

Общая формула преобразования:

~~~~
метод СчётноеН(Строка строка) СчётноеН?
~~~~

где буква Н обозначает одно из чисел: 8, 16, 32, 64, или пустое значение.

Если строка представляет собой последовательность символов, как у литерала целого (смотри главу [2.7.1. Целые числа](#2.7.1)) или шестнадцатеричного числа (смотри главу [2.7.2. Цифра в шестнадцатеричном формате](#2.7.2)), то такая строка преобразуется в Счётное число. В ином случае функция преобразования возвращает значение Пусто. Если значение числа записанное в строке не может вместиться в размер числа, то результатом преобразования также будет значение Пусто.

Примеры преобразования:

~~~~
поле строка1 = "123"
поле число1 = Счётное(строка1) // число1 = Счётное?(123)

поле строка2 = "-123"
поле число2 = Счётное(строка2) // число2 = Счётное?(Пусто)

поле строка3 = "123.1"
поле число3 = Счётное(строка3) // число3 = Счётное?(Пусто)
~~~~

<a name=5.2.16></a>
#### 5.2.16. Преобразование из булева числа в дробное число.

Общая формула преобразования:

~~~~
метод ДробноеН(Буль буль) ДробноеН
~~~~

где буква Н обозначает одно из чисел 32, 64, или пустое значение.

Значение "Нет" преобразуется в число 0.0, значение "Да" преобразуется в число 1.0 для любого типа из линейки дробных чисел.

Примеры преобразования:

~~~~
поле А = Дробное(Нет) // А = 0.0
поле Б = Дробное32(Да) // Б = 1.0
~~~~

<a name=5.2.17></a>
#### 5.2.17. Преобразование из целого числа в дробное число.

Общая формула преобразования:

~~~~
метод ДробноеН(ЦелоеМ целое) ДробноеН
~~~~

где буква М обозначает одно из чисел: 8, 16, 32, 64, или пустое значение, а Н - одно из чисел: 32, 64, или пустое значение.

Целое число преобразуется в дробное с учётом точности дробного числа.

Пример преобразования типа Целое в тип Дробное:

~~~~
поле А = -1
поле Б = Дробное(А) // Б = -1.0
~~~~

<a name=5.2.18></a>
#### 5.2.18. Преобразование из счётного числа в дробное число.

Общая формула преобразования:

~~~~
метод ДробноеН(СчётноеМ счётное) ДробноеН
~~~~

где буква М обозначает одно из чисел: 8, 16, 32, 64, или пустое значение, а Н - одно из чисел: 32, 64, или пустое значение.

Счётное число преобразуется в дробное с учётом точности дробного числа.

Примеры преобразования:

~~~~
поле А = Счётное(256)
поле Б = Дробное(А) // Б = 256.0
~~~~

<a name=5.2.19></a>
#### 5.2.19. Преобразование из дробного числа в дробное число.

Общая формула преобразования:

~~~~
метод ДробноеН(ДробноеМ дробное) ДробноеН
~~~~

где буквы М и Н обозначает одно из чисел 32, 64, или пустое значение.

Дробное число преобразуется в ближайшее возможное дробное число. Если дробное число преобразуется в дробное число меньшей точности и выходит за возможный ранг, то он преобразуется в значение ПлюсБесконечность или МинусБесконечность.

Примеры преобразования:

~~~~
поле А = 256.5
поле Б = Дробное32(А) // Б = Дробное32(256.5)

поле В = ПлюсБесконечность
поле Г = Дробное32(В) // Г = Дробное32(ПлюсБесконечность)
~~~~

<a name=5.2.20></a>
#### 5.2.20. Преобразование из строки в дробное число.

Общая формула преобразования:

~~~~
метод ДробноеН(Строка строка) ДробноеН?
~~~~

где буква Н обозначает одно из чисел 32, 64, или пустое значение.

Если строка представляет собой последовательность символов, как у литерала целого (смотри главу [2.7.1. Целые числа](#2.7.1)) или шестнадцатеричного числа (смотри главу [2.7.2. Цифра в шестнадцатеричном формате](#2.7.2)) или числа с плавающей точкой (смотри главу [2.7.3. Числа с плавающей точкой](#2.7.3)), то такая строка преобразуется в число с плавающей точкой. В ином случае функция преобразования возвращает значение НеЧисло. Если значение числа записанное в строке не может вместиться в размер числа, то результатом преобразования будет значение ПлюсБесконечность или МинусБесконечность. Кроме того, есть следующие правила:

* Знак, разделяющий целую и дробную часть может быть как точка (".") так и запятая (",").
* Дробное число со значением плюс бесконечность может быть записано следующими строковыми значениями: "∞", "+∞", "Бесконечность", "ПлюсБесконечность".
* Дробное число со значением минус бесконечность может быть записано следующими строковыми значениями: "-∞", "МинусБесконечность".

Примеры преобразования:

~~~~
поле строка1 = "123"
поле число1 = Дробное(строка1) // число1 = 123

поле строка2 = "-123"
поле число2 = Дробное(строка2) // число2 = -123

поле строка3 = "123.1"
поле число3 = Дробное(строка3) // число3 = 123.1
~~~~

<a name=5.2.21></a>
#### 5.2.21. Преобразование из булева числа в строку.

Общая формула преобразования:

~~~~
метод Строка(Буль буль) Строка
~~~~

Значение "Нет" преобразуется в строку "Нет", значение "Да" преобразуется в строку "Да".

Примеры преобразования:

~~~~
поле А = Строка(Нет) // А = "Нет"
поле Б = Строка(Да) // Б = "Да"
~~~~

<a name=5.2.22></a>
#### 5.2.22. Преобразование из целого числа в строку.

Общая формула преобразования:

~~~~
метод Строка(ЦелоеМ целое) Строка
~~~~

где буква М обозначает одно из чисел: 8, 16, 32, 64, или пустое значение.

Целое число преобразуется в строку. В начале строки может стоять знак минус для отрицательного числа, а затем следует последовательность цифр.

Пример преобразования типа Целое в тип Строка:

~~~~
поле А = -1
поле Б = Строка(А) // Б = "-1"
~~~~

<a name=5.2.23></a>
#### 5.2.23. Преобразование из счётного числа в строку.

Общая формула преобразования:

~~~~
метод Строка(СчётноеМ счётное) Строка
~~~~

где буква М обозначает одно из чисел: 8, 16, 32, 64, или пустое значение.

Счётное число преобразуется в строку. Преобразованная строка представляет собой последовательность цифр.

Примеры преобразования:

~~~~
поле А = Счётное(256)
поле Б = Строка(А) // Б = "256"
~~~~

<a name=5.2.24></a>
#### 5.2.24. Преобразование из дробного числа в строку.

Общая формула преобразования:

~~~~
метод Строка(ДробноеМ дробное) Строка
~~~~

где буква М обозначает одно из чисел 32, 64, или пустое значение.

Числа, чей модуль находится в пределах больше или равно 0.0001 и меньше 10000 преобразуются в обычную запись числа с плавающей точкой. Количество знаков после запятой равно 6. Символом, отделяющим целую и дробную часть является символ ",".

Если модуль преобразуемого числа меньше 0.0001 или больше или равен 10000, то оно преобразуется в экспоненциальную запись числа с плавающей точкой. Мантисса при этом имеет значение большее или равное 1.0 и меньше, чем 10.0. У мантиссы количество знаков после запятой равно 6. Символ ".", отделяющий целую и дробную часть числа превращается в символ ",". Мантисса и степень отделяются символом "с". Степень задаётся целым числом. Степень всегда содержит минимум две цифры или больше, если необходимо. Степень всегда содержит знак (плюс или минус).

Единственное исключение из предыдущего параграфа: если число равно 0,0, +0,0 или -0,0, то оно преобразуется в обычную запись.

Если значение преобразуемого числа равно НеЧисло, то оно преобразуется в строку "НеЧисло". Если значение равно Бесконечность или ПлюсБесконечность, то оно преобразуется в "∞", если значение равно МинусБесконечность, то оно преобразуется в "-∞".

Примеры преобразования:

~~~~
поле А = 256.5
поле Б = Строка(А) // Б = "256,5"

поле В = ПлюсБесконечность
поле Г = Строка(В) // Г = "∞"
~~~~

<a name=5.2.25></a>
#### 5.2.25. Преобразование из строки в строку.

Общая формула преобразования:

~~~~
метод Строка(Строка строка) Строка
~~~~

Фактически это копирование строки.

Примеры преобразования:

~~~~
поле строка1 = "АБВ"
поле строка2 = Строка(строка1) // строка2 = "АБВ"
~~~~

<a name=5.3></a>
### 5.3. Операция скобки (операция изменения приоритетов).

Операция скобок меняет приоритет выполнения операций.

Грамматическое описание:

~~~~
ПробельныйСимвол = ПробельныйСимвол|КонецСтроки
Выражение =
    ОткрывающаясяСкобка {ПробельныйСимвол}
    Выражение
    {ПробельныйСимвол} ЗакрывающаясяСкобка
~~~~

Внутри скобок символ конца строки рассматривается как пробельный символ.

Общая формула преобразования:

~~~~
метод Скобки(Тип Выражение1) Тип
~~~~

Тип выходного выражения равен типу входного выражения. Тип может быть любой.

Пример:

~~~~
поле А = ( 35)
~~~~

<a name=5.4></a>
### 5.4. Операция выбора элемента.

Операция выбора элемента обозначается через символ "." и необходим для выбора поля или метода класса.

Грамматическое описание:

~~~~
Выражение = Выражение СимволТочка Выражение
~~~~

Формула:

~~~~
<Имя элемента>.<Имя элемента>
~~~~

Тип выходного выражения равен типу элемента.

Пример:

~~~~
Целое32.Макс
~~~~

<a name=5.5></a>
### 5.5. Операция обращения к методу.

Грамматическое описание:

~~~~
Выражение =
    Идентификатор ОткрывающаясяСкобка
    [ {ПробельныйСимвол} Выражение {ПробельныйСимвол}
    {Запятая {ПробельныйСимвол} Выражение {ПробельныйСимвол} } ]
    ЗакрывающаясяСкобка
~~~~

Формула:

~~~~
<Имя метода>([Параметр1 [, Параметр2 [..., ПараметрН]]])
~~~~

Операция обращения к методу обозначается через имя метода и последующим за ним круглых скобок. Внутри скобок через запятую перечисляются параметры метода, если они есть.
Вычисления выражений в аргументах функций происходят в том порядке, в котором они определены в функции.

Пример:

~~~~
Консоль.Вывод("Привет, мир!!!".Длина())
~~~~

<a name=5.6></a>
### 5.6. Операция неопределённости.

"?" - оператор, обозначающий неопределенность типа.

Грамматическое описание:

~~~~
Выражение = Выражение СимволНеопределённость
~~~~

Формула:

~~~~
<Тип>?
~~~~

Оператор неопределенность применяется к типу. В результате получается неопределённый тип. Неопределённый тип может принимать те же значения, что и определённый тип, но имеет дополнительное значение Пусто.

Пример:

~~~~
поле к1 = Целое?(Пусто)
поле к2 = Целое?(4)
~~~~

<a name=5.7></a>
### 5.7. Операция определённости.

"!" - оператор разрешающий неопределенность.

Грамматическое описание:

~~~~
Выражение =
    Выражение {ПробельныйСимвол}
    СимволОпределённость
    {ПробельныйСимвол} Выражение
~~~~

Формула:

~~~~
метод Определённость(Тип? поле1, Тип поле2) Тип
~~~~

Оператор определённости применяется к неопределённому типу и возвращает соответствующий ему определённый тип. В случае, если левое выражение не имеет значение пусто, то возвращается значение левого выражения, в противном случае значение правого выражения.

Пример:

~~~~
поле к = Целое?(Пусто)
...

Консоль.Вывод(к ! 0)
~~~~

В этом примере печатается значение к или 0, если к имеет значение Пусто.

<a name=5.8></a>
### 5.8. Операция унарный плюс.

"+" - унарный плюс.

Грамматическое описание:

~~~~
Выражение = СимволПлюс {ПробельныйСимвол} Выражение
~~~~

Формула для целых, счётных и дробных типов:

~~~~
метод УнарныйПлюс(Тип поле) Тип
метод УнарныйПлюс(Тип? поле) Тип?
~~~~

Где тип - это любой целый, счётный или дробный тип. Результат операции возвращает входное значение.

В случае с неопределённым входным типом, операция работает также, как с определённым, но с дополнением. Если входное значение Пусто, то и выходное значение также будет Пусто.

Частный случай для дробных чисел: +НеЧисло = НеЧисло.

Пример:

~~~~
поле А = 5
поле Б = +А // Б = 5
~~~~

<a name=5.9></a>
### 5.9. Операция унарный минус.

"-" - унарный минус.

Грамматическое описание:

~~~~
Выражение = СимволМинус {ПробельныйСимвол} Выражение
~~~~

Формула для целых и дробных типов:

~~~~
метод УнарныйМинус(Тип поле) Тип
метод УнарныйМинус(Тип? поле) Тип?
~~~~

Где тип - это любой целый или дробный тип. Результат операции возвращает противоположное число.

В случае с неопределённым входным типом, операция работает также, как с определённым, но с дополнением. Если входное значение Пусто, то и выходное значение также будет Пусто.

Частный случай для дробных чисел: -НеЧисло = НеЧисло.

Пример:

~~~~
поле А = 5
поле Б = -А // Б = -5

поле В = Целое8(-128)
поле Г = -В // Г = Целое8(-128)
~~~~

<a name=5.10></a>
### 5.10. Операция сложения.

"+" - сложение.

Грамматическое описание:

~~~~
Выражение =
    Выражение {ПробельныйСимвол}
    СимволПлюс
    {ПробельныйСимвол} Выражение
~~~~

Формула для целых, счётных и дробных типов:

~~~~
метод Плюс(Тип поле1, Тип поле2) Тип
метод Плюс(Тип? поле1, Тип поле2) Тип?
метод Плюс(Тип поле1, Тип? поле2) Тип?
метод Плюс(Тип? поле1, Тип? поле2) Тип?
~~~~

Где тип - это любой целый, счётный или дробный тип. Результатом операции является сумма двух чисел.

В случае если хотя бы одно из входных значений имеет неопределённый тип, то и выходное значение имеет неопределённый тип. Если значение любого из неопределённых типов равно Пусто, то и выходное значение имеет значение Пусто.

Формула для строк:

~~~~
метод Плюс(Строка поле1, Строка поле2) Строка
метод Плюс(Строка? поле1, Строка поле2) Строка?
метод Плюс(Строка поле1, Строка? поле2) Строка?
метод Плюс(Строка? поле1, Строка? поле2) Строка?
~~~~

Результатом операции является конкатенация ("склеивание") двух строк.

В случае если хотя бы одно из входных значений имеет неопределённый тип, то и выходное значение имеет неопределённый тип. Если значение любого из неопределённых типов равно Пусто, то и выходное значение имеет значение Пусто.

Пример:

~~~~
поле А = 5 + 3 // А = 8
поле Б = "Привет, " + "мир!" // Б = "Привет, мир!"
поле В = Целое8(127) + Целое8(1) // В = Целое8(-128)
~~~~

<a name=5.11></a>
### 5.11. Операция вычитания.

"-" - вычитание.

Грамматическое описание:

~~~~
Выражение =
    Выражение {ПробельныйСимвол}
    СимволМинус
    {ПробельныйСимвол} Выражение
~~~~

Формула для целых, счётных и дробных типов:

~~~~
метод Минус(Тип поле1, Тип поле2) Тип
метод Минус(Тип? поле1, Тип поле2) Тип?
метод Минус(Тип поле1, Тип? поле2) Тип?
метод Минус(Тип? поле1, Тип? поле2) Тип?
~~~~

Где тип - это любой целый, счётный или дробный тип. Результатом операции является разность двух чисел.

В случае если хотя бы одно из входных значений имеет неопределённый тип, то и выходное значение имеет неопределённый тип. Если значение любого из неопределённых типов равно Пусто, то и выходное значение имеет значение Пусто.

Пример:

~~~~
поле А = 5 - 6 // А = -1
поле Б = А - 5 // Б = -6
~~~~

<a name=5.12></a>
### 5.12. Операция умножение.

"*" - умножение.

Грамматическое описание:

~~~~
Выражение =
    Выражение {ПробельныйСимвол}
    СимволУмножить
    {ПробельныйСимвол} Выражение
~~~~

Формула для целых, счётных и дробных типов:

~~~~
метод Умножить(Тип поле1, Тип поле2) Тип
метод Умножить(Тип? поле1, Тип поле2) Тип?
метод Умножить(Тип поле1, Тип? поле2) Тип?
метод Умножить(Тип? поле1, Тип? поле2) Тип?
~~~~

Где тип - это любой целый, счётный или дробный тип. Результатом операции является произведение двух чисел.

В случае если хотя бы одно из входных значений имеет неопределённый тип, то и выходное значение имеет неопределённый тип. Если значение любого из неопределённых типов равно Пусто, то и выходное значение имеет значение Пусто.

Пример:

~~~~
поле А = 5 * 6 // А = 30
поле Б = А * 5 // Б = 150
~~~~

<a name=5.13></a>
### 5.13. Операция деление.

"/" - деление.

Грамматическое описание:

~~~~
Выражение =
    Выражение {ПробельныйСимвол}
    СимволРазделить
    {ПробельныйСимвол} Выражение
~~~~

Формула для целых и счётных типов:

~~~~
метод Разделить(Тип поле1, Тип поле2) Тип?
метод Разделить(Тип? поле1, Тип поле2) Тип?
метод Разделить(Тип поле1, Тип? поле2) Тип?
метод Разделить(Тип? поле1, Тип? поле2) Тип?
~~~~

Где тип - это любой целый или счётный тип. Результатом операции является целочисленное частное двух чисел. В результате работы операции значение Пусто может быть получено в случае арифметического переполнения или деления на 0.

В случае если хотя бы одно из входных значений имеет неопределённый тип и значение Пусто, то и выходное значение имеет значение Пусто.

Формула для дробных чисел:

~~~~
метод Разделить(Тип поле1, Тип поле2) Тип
метод Разделить(Тип? поле1, Тип поле2) Тип?
метод Разделить(Тип поле1, Тип? поле2) Тип?
метод Разделить(Тип? поле1, Тип? поле2) Тип?
~~~~

Где тип - это любой дробный тип. Результатом операции является частное двух чисел.

В случае если хотя бы одно из входных значений имеет неопределённый тип и значение Пусто, то и выходное значение имеет значение Пусто.

Пример:

~~~~
поле А = 7 / 2 // А = Целое?(3)
поле А = 7 / 0 // А = Целое?(Пусто)
поле Б = 7.0 / 2.0 // Б = 3.5
~~~~

<a name=5.14></a>
### 5.14. Операция защищённое деление.

"/!" - защищённое деление.

Грамматическое описание:

~~~~
Выражение =
    Выражение {ПробельныйСимвол}
    ОпРазделитьЗащищённое
    {ПробельныйСимвол} Выражение
~~~~

Формула для целых и счётных типов:

~~~~
метод РазделитьЗащищённо(Тип поле1, Тип поле2) Тип
метод РазделитьЗащищённо(Тип? поле1, Тип поле2) Тип?
метод РазделитьЗащищённо(Тип поле1, Тип? поле2) Тип?
метод РазделитьЗащищённо(Тип? поле1, Тип? поле2) Тип?
~~~~

Где тип - это любой целый или счётный тип. Результатом операции является целочисленное частное двух чисел. Отличие от простого деления в том, что при делении на ноль операция возвращает значение делимого (замена на деление на единицу).

В случае если хотя бы одно из входных значений имеет неопределённый тип, то и выходное значение имеет неопределённый тип. Если значение любого из неопределённых типов равно Пусто, то и выходное значение имеет значение Пусто.

~~~~
поле А = 7 /! 2 // А = 3
поле Б = 7 /! 0 // А = 7
~~~~

<a name=5.15></a>
### 5.15. Операция остаток от деления.

"%" - остаток.

Грамматическое описание:

~~~~
Выражение =
    Выражение {ПробельныйСимвол}
    СимволОстаток
    {ПробельныйСимвол} Выражение
~~~~

Формула:

~~~~
метод ПолучитьОстаток(Тип поле1, Тип поле2) Тип?
метод ПолучитьОстаток(Тип? поле1, Тип поле2) Тип?
метод ПолучитьОстаток(Тип поле1, Тип? поле2) Тип?
метод ПолучитьОстаток(Тип? поле1, Тип? поле2) Тип?
~~~~

Где тип - это любой целый или счётный тип. Результатом операции является целочисленный остаток от деления двух чисел. В результате работы операции значение Пусто может быть получено в случае арифметического переполнения или деления на 0.

В случае если хотя бы одно из входных значений имеет неопределённый тип и значение Пусто, то и выходное значение имеет значение Пусто.

~~~~
поле А = 5 % 3 // А = Целое?(2)
поле Б = 6 % 0 // Б = Целое?(Пусто)
~~~~

<a name=5.16></a>
### 5.16. Операция защищённый остаток от деления.

"%" - защищённый остаток.

Грамматическое описание:

~~~~
Выражение =
    Выражение {ПробельныйСимвол}
    ОпОстатокЗащищённый
    {ПробельныйСимвол} Выражение
~~~~

Формула:

~~~~
метод ПолучитьОстатокЗащищённо(Тип поле1, Тип поле2) Тип
метод ПолучитьОстатокЗащищённо(Тип? поле1, Тип поле2) Тип?
метод ПолучитьОстатокЗащищённо(Тип поле1, Тип? поле2) Тип?
метод ПолучитьОстатокЗащищённо(Тип? поле1, Тип? поле2) Тип?
~~~~

Где тип - это любой целый или счётный тип. Результатом операции является целочисленный остаток от деления двух чисел. Отличие от простого остатка от деления в том, что при делении на ноль операция возвращает единицу (замена на остаток от деления на единицу).

В случае если хотя бы одно из входных значений имеет неопределённый тип, то и выходное значение имеет неопределённый тип. Если значение любого из неопределённых типов равно Пусто, то и выходное значение имеет значение Пусто.

~~~~
поле А = 5 % 3 // А = 2
поле Б = 6 % 0 // Б = 6
~~~~

<a name=5.17></a>
### 5.17. Операция побитовое И.

"би" - побитовое И.

Грамматическое описание:

~~~~
Выражение = Выражение Пробел ОпПобитовоеИ Пробел Выражение
~~~~

Формула:

~~~~
метод ПобитовоеИ(Тип поле1, Тип поле2) Тип
метод ПобитовоеИ(Тип? поле1, Тип поле2) Тип?
метод ПобитовоеИ(Тип поле1, Тип? поле2) Тип?
метод ПобитовоеИ(Тип? поле1, Тип? поле2) Тип?
~~~~

Где тип - это любой целый или счётный тип. Результатом операции является побитовое И двух чисел.

В случае если хотя бы одно из входных значений имеет неопределённый тип и значение Пусто, то и выходное значение имеет значение Пусто.

Пример:

~~~~
поле А = Целое8(5) // 00000101 в двоичной системе.
поле Б = Целое8(3) // 00000011 в двоичной системе.
поле В = А би Б // В = 1, или 00000001 в двоичной системе.
~~~~

<a name=5.18></a>
### 5.18. Операция побитовое ИЛИ.

"били" - побитовое ИЛИ.

Грамматическое описание:

~~~~
Выражение = Выражение Пробел ОпПобитовоеИли Пробел Выражение
~~~~

Формула:

~~~~
метод ПобитовоеИЛИ(Тип поле1, Тип поле2) Тип
метод ПобитовоеИЛИ(Тип? поле1, Тип поле2) Тип?
метод ПобитовоеИЛИ(Тип поле1, Тип? поле2) Тип?
метод ПобитовоеИЛИ(Тип? поле1, Тип? поле2) Тип?
~~~~

Где тип - это любой целый или счётный тип. Результатом операции является побитовое ИЛИ двух чисел.

В случае если хотя бы одно из входных значений имеет неопределённый тип и значение Пусто, то и выходное значение имеет значение Пусто.

Пример:

~~~~
поле А = Целое8(5) // 00000101 в двоичной системе.
поле Б = Целое8(3) // 00000011 в двоичной системе.
поле В = А били Б // В = 7, или 00000111 в двоичной системе.
~~~~

<a name=5.19></a>
### 5.19. Операция побитовое исключающее ИЛИ.

"билине" - побитовое исключающее ИЛИ.

Грамматическое описание:

~~~~
Выражение =
    Выражение Пробел ОпПобитовоеИсключающееИли Пробел Выражение
~~~~

Формула:

~~~~
метод ПобитовоеИсключающееИЛИ(Тип поле1, Тип поле2) Тип
метод ПобитовоеИсключающееИЛИ(Тип? поле1, Тип поле2) Тип?
метод ПобитовоеИсключающееИЛИ(Тип поле1, Тип? поле2) Тип?
метод ПобитовоеИсключающееИЛИ(Тип? поле1, Тип? поле2) Тип?
~~~~

Где тип - это любой целый или счётный тип. Результатом операции является побитовое исключающее ИЛИ двух чисел.

В случае если хотя бы одно из входных значений имеет неопределённый тип и значение Пусто, то и выходное значение имеет значение Пусто.

Пример:

~~~~
поле А = Целое8(5) // 00000101 в двоичной системе.
поле Б = Целое8(3) // 00000011 в двоичной системе.
поле В = А били Б // В = 6, или 00000110 в двоичной системе.
~~~~

<a name=5.20></a>
### 5.20. Операция побитовое НЕ.

"бне" - побитовое НЕ.

Грамматическое описание:

~~~~
Выражение = ОпПобитовоеНе Пробел Выражение
~~~~

Формула:

~~~~
метод ПобитовоеНЕ(Тип поле) Тип
метод ПобитовоеНЕ(Тип? поле) Тип?
~~~~

Где тип - это любой целый или счётный тип. Результатом операции является побитовое НЕ числа.

В случае если входное значение имеет неопределённый тип и равно Пусто, то и выходное значение имеет значение Пусто.

Пример:

~~~~
поле А = Целое8(6) // 00000110 в двоичной системе.
поле Б = бне А // Б = -7, или 11111001 в двоичной системе.
~~~~

<a name=5.21></a>
### 5.21. Операция побитовый сдвиг вправо.

"вправо" - побитовый сдвиг вправо.

Грамматическое описание:

~~~~
Выражение = Выражение Пробел ОпБитыВправо Пробел Выражение
~~~~

Формула:

~~~~
метод ПобитовыйСдвигВправо(Тип1 поле1, Тип2 поле2) Тип1
метод ПобитовыйСдвигВправо(Тип1? поле1, Тип2 поле2) Тип1?
метод ПобитовыйСдвигВправо(Тип1 поле1, Тип2? поле2) Тип1?
метод ПобитовыйСдвигВправо(Тип1? поле1, Тип2? поле2) Тип1?
~~~~

Где Тип1 и Тип2 - это любой целый или счётный тип. Результатом операции является побитовый сдвиг вправо числа поле1 на поле2 бит. Для целых типов старшие биты заполняются знаковым битом (1 для отрицательных и 0 для положительных чисел). Для счётных типов старшие биты заполняются нулями.

В случае если хотя бы одно из входных значений имеет неопределённый тип и значение Пусто, то и выходное значение имеет значение Пусто.

Пример:

~~~~
поле А = 8 вправо 2 // В двоичной системе 1000(2) вправо 2 = 10(2).
                    // Что в десятичной равно 2.
~~~~

<a name=5.22></a>
### 5.22. Операция побитовый сдвиг влево.

"влево" - побитовый сдвиг влево.

Грамматическое описание:

~~~~
Выражение = Выражение Пробел ОпБитыВлево Пробел Выражение
~~~~

Формула:

~~~~
метод ПобитовыйСдвигВлево(Тип1 поле1, Тип2 поле2) Тип1
метод ПобитовыйСдвигВлево(Тип1? поле1, Тип2 поле2) Тип1?
метод ПобитовыйСдвигВлево(Тип1 поле1, Тип2? поле2) Тип1?
метод ПобитовыйСдвигВлево(Тип1? поле1, Тип2? поле2) Тип1?
~~~~

Где Тип1 и Тип2 - это любой целый или счётный тип. Результатом операции является побитовый сдвиг влево числа поле1 на поле2 бит. Младшие биты заполняются нулями.

В случае если хотя бы одно из входных значений имеет неопределённый тип и значение Пусто, то и выходное значение имеет значение Пусто.

Пример:

~~~~
поле А = 1 влево 2 // В двоичной системе 1(2) влево 2 = 100(2).
                   // Что в десятичной равно 4.
~~~~

<a name=5.23></a>
### 5.23. Операция проверка на равенство.

"==" - проверка на равенство.

Грамматическое описание:

~~~~
Выражение =
    Выражение {ПробельныйСимвол}
    СимволПрисвоение СимволПрисвоение
    {ПробельныйСимвол} Выражение
~~~~

Формула:

~~~~
метод Равно(Тип поле1, Тип поле2) Буль
метод Равно(Тип? поле1, Тип поле2) Буль
метод Равно(Тип поле1, Тип? поле2) Буль
метод Равно(Тип? поле1, Тип? поле2) Буль
~~~~

Где Тип - это любой булевый, целый, счётный, дробный или строковый тип. Результатом операции является проверка на равенство и имеет булевый тип.

Для двух дробных чисел, если они оба имеют значение НеЧисло, результатом их сравнения будет значение Нет.

В случае если оба типа являются неопределенными и значение у обоих является Пусто, то результатом их сравнения будет значение Да.

Пример:

~~~~
поле А = 1 == 2 // А = Нет
поле Б = 1 == Пусто // Б = Нет
поле В = 3 == 3 // В = Да
~~~~

<a name=5.24></a>
### 5.24. Операция проверка на неравенство.

"не=" - проверка на неравенство.

Грамматическое описание:

~~~~
Выражение =
    Выражение {ПробельныйСимвол}
    СимволНеопределённость СимволПрисвоение
    {ПробельныйСимвол} Выражение
~~~~

Формула:

~~~~
метод НеРавно(Тип поле1, Тип поле2) Буль
метод НеРавно(Тип? поле1, Тип поле2) Буль
метод НеРавно(Тип поле1, Тип? поле2) Буль
метод НеРавно(Тип? поле1, Тип? поле2) Буль
~~~~

Где Тип - это любой булевый, целый, счётный, дробный или строковый тип. Результатом операции является проверка на неравенство и имеет булевый тип. Результат сравнения на неравенство всегда противоположен результату сравнения на равенство.

Пример:

~~~~
поле А = 1
поле Б = 1 не= Пусто // Б = Да
поле В = 3 не= 3 // В = Нет
~~~~

<a name=5.25></a>
### 5.25. Операция проверка больше.

"бш" - проверка больше.

Грамматическое описание:

~~~~
Выражение = Выражение Пробел ОпСравненияБольше Пробел Выражение
~~~~

Формула:

~~~~
метод Больше(Тип поле1, Тип поле2) Буль
~~~~

Где Тип - это любой булевый, целый, счётный, дробный или строковый тип. Результатом операции является результат сравнения значений операции больше.

Для булевого типа исходим из аксиомы, что Да больше чем Нет.

Для дробных чисел, если хотя бы одно из чисел имеет значение НеЧисло, то результатом сравнения будет значение Нет.

Для строковых значений сравнение происходит посимвольно, согласно номерам символов в кодировке Юникод.

Пример:

~~~~
поле А = 2 бш 3 // А = Нет
поле Б = 3 бш 2 // Б = Да
поле В = 3 бш 3 // В = Нет
~~~~

<a name=5.26></a>
### 5.26. Операция проверка больше или равно.

"бир" - проверка больше или равно.

Грамматическое описание:

~~~~
Выражение =
    Выражение Пробел ОпСравненияБольшеИлиРавно Пробел Выражение
~~~~

Формула:

~~~~
метод БольшеИлиРавно(Тип поле1, Тип поле2) Буль
~~~~

Где Тип - это любой булевый, целый, счётный, дробный или строковый тип. Результатом операции является результат сравнения значений операции больше или равно.

Для булевого типа исходим из аксиомы, что Да больше чем Нет.

Для дробных чисел, если хотя бы одно из чисел имеет значение НеЧисло, то результатом сравнения будет значение Нет.

Для строковых значений сравнение происходит посимвольно, согласно номерам символов в кодировке Юникод.

Пример:

~~~~
поле А = 2 бир 3 // А = Нет
поле Б = 3 бир 2 // Б = Да
поле В = 3 бир 3 // В = Да
~~~~

<a name=5.27></a>
### 5.27. Операция проверка меньше.

"мш" - проверка меньше.

Грамматическое описание:

~~~~
Выражение = Выражение Пробел ОпСравненияМеньше Пробел Выражение
~~~~

Формула:

~~~~
метод Меньше(Тип поле1, Тип поле2) Буль
~~~~

Где Тип - это любой булевый, целый, счётный, дробный или строковый тип. Результатом операции является результат сравнения значений операции меньше.

Для булевого типа исходим из аксиомы, что Да больше чем Нет.

Для дробных чисел, если хотя бы одно из чисел имеет значение НеЧисло, то результатом сравнения будет значение Нет.

Для строковых значений сравнение происходит посимвольно, согласно номерам символов в кодировке Юникод.

Пример:

~~~~
поле А = 2 мш 3 // А = Да
поле Б = 3 мш 2 // Б = Нет
поле В = 3 мш 3 // В = Нет
~~~~

<a name=5.28></a>
### 5.28. Операция проверка меньше или равно.

"мир" - проверка меньше или равно.

Грамматическое описание:

~~~~
Выражение =
    Выражение Пробел ОпСравненияМеньшеИлиРавно Пробел Выражение
~~~~

Формула:

~~~~
метод МеньшеИлиРавно(Тип поле1, Тип поле2) Буль
~~~~

Где Тип - это любой булевый, целый, счётный, дробный или строковый тип. Результатом операции является результат сравнения значений операции меньше или равно.

Для булевого типа исходим из аксиомы, что Да больше чем Нет.

Для дробных чисел, если хотя бы одно из чисел имеет значение НеЧисло, то результатом сравнения будет значение Нет.

Для строковых значений сравнение происходит посимвольно, согласно номерам символов в кодировке Юникод.

Пример:

~~~~
поле А = 2 мир 3 // А = Да
поле Б = 3 мир 2 // Б = Нет
поле В = 3 мир 3 // В = Да
~~~~

<a name=5.29></a>
### 5.29. Операция логическое И.

"и" - логическое И.

Грамматическое описание:

~~~~
Выражение = Выражение Пробел ОпЛогическоеИ Пробел Выражение
~~~~

Формула:

~~~~
метод ЛогическоеИ(Буль поле1, Буль поле2) Буль
~~~~

Результатом операции является логическое И двух булевых переменных.

Пример:

~~~~
поле А = Да и Да // А = Да
поле Б = Да и Нет // Б = Нет
~~~~

<a name=5.30></a>
### 5.30. Операция логическое ИЛИ.

"или" - логическое ИЛИ.

Грамматическое описание:

~~~~
Выражение = Выражение Пробел ОпЛогическоеИли Пробел Выражение
~~~~

Формула:

~~~~
метод ЛогическоеИЛИ(Буль поле1, Буль поле2) Буль
~~~~

Результатом операции является логическое ИЛИ двух булевых переменных.

Пример:

~~~~
поле А = Да или Нет // А = Да
поле Б = Нет или Нет // Б = Нет
~~~~

<a name=5.31></a>
### 5.31. Операция логическое НЕ.

"не" - логическое НЕ.

Грамматическое описание:

~~~~
Выражение = ОпЛогическоеНе Пробел Выражение
~~~~

Формула:

~~~~
метод ЛогическоеНЕ(Буль поле) Буль
~~~~

Результатом операции является логическое НЕ булевой переменной.

Пример:

~~~~
поле А = не Нет // А = Да
поле Б = не Да // Б = Нет
~~~~

<a name=5.32></a>
### 5.32. Приоритет операций.

Ниже описан приоритет операций а также ассоциативность.

|Приоритет|Операция|Ассоциативность|Описание|
|---------|:------:|---------------|--------|
|1|()|слева направо|изменение приоритета операции, параметры при вызове метода, преобразование типов|
|2|. .метод(,,)|слева направо|обращение к элементу, вызов метода|
|3|?||неопределенность|
|4|!|слева направо|разрешение неопределенности|
|5|+ - не бне||унарный плюс, унарный минус, логическое НЕ, побитовое НЕ|
|6|* / /! % %! |слева направо|умножение, деление, защищённое деление, остаток от деления, защищённый остаток от деления|
|7|+ -|слева направо|сложение, вычитание|
|8|вправо влево|слева направо|побитовый сдвиг вправо, побитовый сдвиг влево|
|9|бш бир мш мир|слева направо|больше, больше или равно, меньше, меньше или равно|
|10|== не=|слева направо|равно, не равно|
|11|би|слева направо|побитовое И|
|12|билине|слева направо|побитовое исключающее ИЛИ|
|13|били|слева направо|побитовое ИЛИ|
|14|и|слева направо|логическое И|
|15|или|слева направо|логическое ИЛИ|

<a name=5.33></a>
### 5.33. Дополнительные уточнения по операциям.

<a name=5.33.1></a>
#### 5.33.1. Числовые типы и литералы.

В главе [5.1. Простейшее выражение](#5.1) написано, что литерал ЦелоеЧисло явлется типом Целое (что равносильно типу Целое32), а литерал ШестнадцатеричноеЧисло является типом Счётное (что равносильно типу Счётное32).

Однако, в таком случае для типов Целое64 и Счётное64 сложно написать большие значения чисел, так как в этом случае значение литералов будет обрезаться из-за переполнения.

Поэтому необходимо ввести дополнительные правила для работы с литералами. Для десятиных литералов введём следующие правила:

* допустимый диапазон чисел для десятичных литералов колеблется от -9223372036854775808 до 18446744073709551615, то есть от минимального значения диапазона Целое64 до максимального значения диапазона Счётное64.
* если операции производятся между двумя десятичными литералами, то это эквивалентно операции между двумя 64-ричными целыми.
* при присваивании или вызове функции десятичный литерал или выражение состоящее только из десятичных литералов приводится к типу Целое32.
* если операция производится между десятичным литералом и каким-либо типом, то десятичный литерал приводится к данному типу из 64-ричного целого типа.

Похожие правила действуют для шестнадцатеричных литералов:

* допустимый диапазон чисел для шестнадцатеричных литералов колеблется от 0ш0 до 0шЕЕЕЕЕЕЕЕЕЕЕЕЕЕЕЕ, то есть совпадает с диапазоном значений типа Счётное64.
* если операции производятся между двумя шестнадцатеричными литералами, то это эквивалентно операции между двумя 64-ричными счётными.
* при присваивании или вызове функции шестнадцатеричный литерал или выражение состоящее только из шестнадцатеричных литералов приводится к типу Счётное32.
* если операция производится между шестнадцатеричными литералом и каким-либо типом, то шестнадцатеричный литерал приводится к данному типу из 64-ричного счётного типа.

Для литералов с плавающей точкой по-умолчанию для операций и для присваивания используется один и тот же тип Дробное64. А тип Дробное32 может появиться только при явном преобразовании. Поэтому правила будут немного проще:

* если операции производятся между двумя литералами с плавающей точкой, то это эквивалентно операции между двумя переменными с типом Дробное64.
* при присваивании или вызове функции литерал с плавающей точкой или выражение состоящее только из таких литералов приводится к типу Дробное64.
* если операция производится между литералом с плавающей точкой и одним из дробных типов, то литерал с плавающей точкой приводится к данному дробному типу. Если переменная в операции имеет тип, отличный от дробного, то происходит ошибка компиляции.

И дополнительное правило:

* любые операции между десятичными, шестнадцатеричными и дробными литералами без явного преобразования типов запрещены.

Примеры.

Пример 1.

~~~~
2 + 3
~~~~

Так как это операция между двумя десятичными литералами, то они проводятся между 64-ричными числами. Эквивалентная запись:

~~~~
Целое64(2) + Целое64(3)
~~~~

Пример 2.

~~~~
поле А = 2 + 3
~~~~

Здесь сложение идёт между 64-ричными целыми числами, но перед присвоением результат преобразуется в 32-разрядный целый. То есть, эквивалентная запись будет такой:

~~~~
поле А = Целое32(Целое64(2) + Целое64(3))
~~~~

Пример 3.

~~~~
Консоль.Печать(2 + 3)
~~~~

Здесь похоже на предыдущий пример: сложение идёт между 64-ричными целыми числами, но перед вызовом функции результат преобразуется в 32-разрядный целый. То есть, эквивалентная запись будет такой:

~~~~
Консоль.Печатать(Целое32(Целое64(2) + Целое64(3)))
~~~~

Если необходима печать именно 64-ричного числа, то необходимо прямо это указать:

~~~~
Консоль.Печать(Целое64(2 + 3))
~~~~

или через дополнительную переменную:

~~~~
поле А = Целое64(2 + 3)
Консоль.Печать(А)
~~~~

Пример 4.

~~~~
поле А = Целое8(5)
поле Б = А + 5
~~~~

Здесь во второй строке складывается литерал с переменной типа Целое8. Значит перед сложением литерал приводится к типу Целое8. Эквивалентная запись будет такой:

~~~~
поле А = Целое8(5)
поле Б = Целое8(Целое8(А) + Целое8(5))
~~~~

Пример 5.

~~~~
Консоль.Печать(0ш2 + 0ш3)
~~~~

Сложение идёт между 64-ричными счётными числами, но перед вызовом функции результат преобразуется в 32-разрядный счётный. То есть, эквивалентная запись будет такой:

~~~~
Консоль.Печатать(Счётное32(Счётное64(0ш2) + Счётное64(0ш3)))
~~~~

Пример 6.

~~~~
поле А = Счётное8(0ш5)
поле Б = А + 0шБ
~~~~

Здесь во второй строке складывается литерал с переменной типа Счётное8. Значит перед сложением литерал приводится к типу Счётное8. Эквивалентная запись будет такой:

~~~~
поле А = Счётное8(0ш5)
поле Б = Счётное8(Счётное8(А) + Счётное8(5))
~~~~

Пример 7.

~~~~
Консоль.Печать(3.2)
поле А = 1.2 + 3.4
поле Б = Дробное32(1.2) + 3.4
~~~~

Эквивалентная запись:

~~~~
Консоль.Печать(Дробное64(3.2))
поле А = Дробное64(Дробное64(1.2) + Дробное64(3.4))
поле Б = Дробное32(Дробное32(1.2) + Дробное32(3.4))
~~~~

Пример 8.

Любое из следующих выражений вызовет ошибку времени компиляции:

~~~~
2 + 0ш3 // Операция над десятичным и шестнадцатеричным литералами без явного преобразования типов.
2 * 3.2 // Операция над десятичным и дробным литералами без явного преобразования типов.
0ш3 - 3.14 // Операция над шестнадцатеричным и дробным литералами без явного преобразования типов.
3.2 * Счётное(2) // Литерал с плавающей точкой может преобразовываться только в дробный тип.
~~~~

Эти выражения допустимы:

~~~~
Целое32(2) + 0ш3 // Эквивалентно Целое32(Целое32(2) + Целое32(0ш3))
~~~~

<a name=5.33.2></a>
#### 5.33.2. Целочисленное деление и остаток для отрицательных чисел.

Для натуральных чисел используется следующее определение целочисленного остатка и частного:

Пусть a и b — целые числа, причём b ≠ 0. Деление с остатком a («делимого») на b («делитель») означает нахождение таких целых чисел q и r, что выполняется равенство:

~~~~
a = b ⋅ q + r
~~~~

Таким образом, результатами деления с остатком являются два целых числа: q называется неполным частным от деления, а r — остатком от деления. На остаток налагается дополнительное условие: 0 ⩽ r < |b|. Это условие обеспечивает однозначность результатов деления с остатком для всех целых чисел

Однако для отрицательных чисел существует несколько альтернативных способов вычисления q и r. В нашем случае для отрицательных чисел введём дополнительное правило:

~~~~
|a| / |b| = |a / b|
~~~~

То есть модуль остатка будет одинаковым, вне зависимости от знака делимого и делителя. На остаток при этом налагается более мягкое условие: -|b| < r < |b|, и знак остатка совпадает со знаком делимого.

Пример:

~~~~
поле А = 7 / 2 // А = Целое?(3)
поле Б = -7 / 2 // Б = Целое?(-3)
поле В = 7 / -2 // В = Целое?(-3)
поле Г = -7 / -2 // Г = Целое?(3)

поле Д = 7 % 2 // Д = Целое?(1)
поле Е = -7 % 2 // Е = Целое?(-1)
поле Ё = 7 % -2 // Ё = Целое?(1)
поле Ж = -7 % -2 // Ж = Целое?(-1)
~~~~

<a name=5.33.3></a>
#### 5.33.3. Вычисление логических операций.

Для логических операций "И", "ИЛИ" используется неполное вычисление.
То есть, если есть несколько аргументов объединённых операцией "И", то вычисление производится до первой операции, вернувшей значение "Нет".
Аналогично, если есть несколько аргументов объединённых операцией "ИЛИ", то вычисление производится до первой операции, вернувшей значение "Да".

<a name=6></a>
## 6. Алгоритм.

<a name=6.1></a>
### 6.1. Общее описание.

Алгоритм - это последовательность команд. Команды могут быть простыми или блочными.

Простые алгоритмы могут быть записаны в одну строку, блочные состоят из блоков, каждых из этих блоков также является алгоритмом.

В данной главе используется 2 вида описания: более строгое грамматическое описание и упрощенное синтаксическое, для лучшего понимания.

В синтаксисе команд применяются специальные символы:

* `[]` - необязательный элемент. Может присутствовать 0 или 1 раз.

* `[]*` - необязательный множественный элемент. Может присутствовать 0, 1 или множество раз.

* `<>` - элемент, который является не конкретным словом, а его сущностью. Например `<Алгоритм>` является алгоритмом.

<a name=6.2></a>
### 6.2. Вычисление выражения.

Команда запускает вычисление выражения.

Грамматическое описание:

~~~~
Алгоритм = Алгоритм |
    ОтступВерхнегоУровня Выражение {ПробельныйСимвол} НоваяСтрока
~~~~

Синтаксис:

~~~~
<Выражение>
~~~~

Вычисление выражения может быть использовано для вызова функции, или, используя неполное вычисление логических функций, можно вызывать не все функции подряд.

<a name=6.3></a>
### 6.3. Выход из алгоритма.

Команда прерывает работу алгоритма и при необходимости возвращает некоторое значение.

Грамматическое описание:

~~~~
ВыходБезЗначения =
    АлгоритмВернуть {ПробельныйСимвол} НоваяСтрока
ВыходСоЗначением =
    АлгоритмВернуть Пробел Выражение {ПробельныйСимвол} НоваяСтрока
Выход = ВыходБезЗначения | ВыходСоЗначением
~~~~

Синтаксис:

~~~~
вернуть
вернуть <Выражение>
~~~~

Выход из алгоритма позволяет прервать выполнение алгоритма и, при необходимости, вернуть значение выражения. Необходимость возвращать значение и тип этого значения зависит от требований элемента, в котором используется алгоритм.

<a name=6.4></a>
### 6.4. Объявление переменной.

Инициализация локальной переменной.

Грамматическое описание:

~~~~
Алгоритм = Алгоритм |
    ОтступВерхнегоУровня
    ОбъявлениеПоля Пробел
    Идентификатор {ПробельныйСимвол}
    СимволПрисвоение {ПробельныйСимвол}
    Выражение {ПробельныйСимвол} НоваяСтрока
~~~~

Синтаксис:

~~~~
поле <Идентификатор> = <Выражение>
~~~~

Объявление локальной переменной для данного блока в алгоритме. Область видимости от места объявления переменной до конца блока.
Имя переменной (Идентификатор) должно быть уникально в пределах текущего блока. В дочерних блоках переменная может перекрываться переменными в дочерних блоках, если они имеют одно и тоже имя.

При объявлении любого поля оно обязательно должно быть инициализировано. Тип переменной определяется по типу выражения справа от знака равенства. Тип переменной определяется при инициализации и далее не меняется.

<a name=6.5></a>
### 6.5. Присваивание.

Грамматическое описание:

~~~~
Алгоритм = Алгоритм |
    ОтступВерхнегоУровня
    Идентификатор {ПробельныйСимвол}
    СимволПрисвоение {ПробельныйСимвол}
    Выражение {ПробельныйСимвол} НоваяСтрока
~~~~

Синтаксис:

~~~~
<Идентификатор> = <Выражение>
~~~~

Присваивает переменной, стоящей слева некоторое значение, вычисляемое по формуле справа. обозначается символом "=". Множественное присваивание запрещено.
Переменная должна быть объявлена заранее. Тип выражения справа должен совпадать с типом переменной.

<a name=6.6></a>
### 6.6. Блок области видимости.

Грамматическое описание:

~~~~
Алгоритм = Алгоритм |

    ОтступВерхнегоУровня
    АлгоритмБлок {ПробельныйСимвол}
    СимволДвоеточие {ПробельныйСимвол} НоваяСтрока

    СтрокаБлока{СтрокаБлока}
~~~~

Синтаксис:

~~~~
блок:
    <Алгоритм>
~~~~

Принцип работы: выполняется тело блока.

Можно применять для организации тела функции. Кроме того, происходит локализация области видимости переменных, объявленных внутри блока. При выходе из блока такие переменные уничтожаются.

<a name=6.7></a>
### 6.7. Блок раскрытия неопределенности.

Грамматическое описание:

~~~~
Алгоритм = Алгоритм |

    ОтступВерхнегоУровня
    АлгоритмРаскрыть Пробел
    Идентификатор {ПробельныйСимвол}
    [АлгоритмКак Пробел
    Идентификатор {ПробельныйСимвол}]
    СимволДвоеточие {ПробельныйСимвол} НоваяСтрока

    СтрокаБлока{СтрокаБлока}

    [
    ОтступВерхнегоУровня
    АлгоритмИначе {ПробельныйСимвол}
    СимволДвоеточие {ПробельныйСимвол} НоваяСтрока

    СтрокаБлока{СтрокаБлока}
    ]
~~~~

Синтаксис:

~~~~
раскрыть <Идентификатор> [как <Идентификатор>]:
    <Алгоритм>
[иначе:
    <Алгоритм>]
~~~~

Блок пытается раскрыть переменную с неопределённостью. Если все переменная раскрыта (не имеет значения "Пусто"), то выполняется тело блока. В теле блока раскрытая переменная уже имеют определённый тип. Если переменная не раскрыта (имеет значение Пусто), то запускается блок "иначе". Блок "иначе" является необязательным.

Если необходимо для раскрытой переменной внутри блока под другим именем, то используется переименование с помощью ключевого слова "как".

<a name=6.8></a>
### 6.8. Условный блок.

Грамматическое описание:

~~~~
Алгоритм = Алгоритм |

    ОтступВерхнегоУровня
    АлгоритмЕсли Пробел
    Выражение {ПробельныйСимвол}
    СимволДвоеточие {ПробельныйСимвол} НоваяСтрока

    СтрокаБлока{СтрокаБлока}

    {
    ОтступВерхнегоУровня
    АлгоритмИначе Пробел
    АлгоритмЕсли Пробел
    Выражение {ПробельныйСимвол}
    СимволДвоеточие {ПробельныйСимвол} НоваяСтрока

    СтрокаБлока{СтрокаБлока}
    }

    [
    ОтступВерхнегоУровня
    АлгоритмИначе {ПробельныйСимвол}
    СимволДвоеточие {ПробельныйСимвол} НоваяСтрока

    СтрокаБлока{СтрокаБлока}
    ]
~~~~

Синтаксис:

~~~~
если <Выражение>:
    <Алгоритм>
[иначе если <Выражение>:
    <Алгоритм>
]*
[иначе:
    <Алгоритм>]
~~~~

Условный блок разделяется на одно или несколько подблоков. Сначала идёт обязательный подблок "если", затем могут идти подблоки "иначе если" (от 0 до бесконечности), и затем может идти подблок "иначе" (0 или 1).

Подблок "если". Сначала пишется ключевое слово "если" затем идет условие, а затем двоеточие. Условие - это выражение, которое возвращает значение типа Буль.
,
Подблок "иначе если" работает подобным способом. Сначала пишутся ключевые слова "иначе" "если", затем идет условие, а затем двоеточие. Условие - это выражение, которое возвращает переменную типа Буль.

В подблоке иначе сначала пишется ключевое слово "иначе", а затем идет двоеточие.

Общая схема работы блока:

- Проверяется условие в подблоке "если". Если условие возвращает значение "Да", то выполняется тело подблока и блок завершает свою работу.
- В противном случае поочередно проверяются условия подблоков "иначе если". Если какое-либо условие возвращает значение "Да", то выполняется соответствующее ему тело подблока и блок завершает свою работу. Последующие условия не проверяются.
- Если ни одно условие не вернуло значение "Да" и есть подблок "иначе", то выполняется тело подблока "иначе" и блок завершает работу.
- Если ни одно условие не вернуло значение "Да" и нет подблока "иначе", то блок завершает работу, не выполняя никаких подблоков.

<a name=6.9></a>
### 6.9. Блок цикла по условию.

Грамматическое описание:

~~~~
Прерывание =
    (
    АлгоритмПрервать {Пробел АлгоритмПрервать} [Пробел АлгоритмСледующий]
    ) | (
    АлгоритмСледующий
    )

СтрокаПрерывания =
    ОтступВерхнегоУровня ОтступБлока
    Прерывание {ПробельныйСимвол} НоваяСтрока

Алгоритм = Алгоритм |

    ОтступВерхнегоУровня
    АлгоритмПока Пробел
    Выражение {ПробельныйСимвол}
    СимволДвоеточие {ПробельныйСимвол} НоваяСтрока

    (СтрокаБлока | СтрокаПрерывания) {СтрокаБлока | СтрокаПрерывания}
~~~~

Синтаксис:

~~~~
пока <Выражение>:
    [<СтрокаПрерывания> | <Алгоритм>]*
~~~~

Блок проверяет сначала Выражение, которое возвращает значение типа Буль. Если значение равно Да, выполняется алгоритм внутри цикла. Затем Выражение проверяется снова и снова выполняется алгоритм. И так до тех пор, пока значение выражения не станет равным Нет. Если значение выражения равно Нет, то блок заканчивает свою работу.

Внутри цикла можно использовать ключевые слова "прервать" и "следующий". Ключевое слово "прервать" прерывает работу цикла и выходит из него. Ключевое слово "следующий" пропускает оставшуюся часть текущей итерации цикла и переходит к следующей итерации.

Можно прервать не только текущий цикл, но и стоящие выше. Для этого надо написать ключевое слово "прервать" столько раз, из скольки циклов вы хотите выйти. И даже, при необходимости, добавить после этого ключевое слово "следующий". Но ключевое слово "следующий" можно добавить только 1 раз.

<a name=7></a>
## 7. Корневые элементы.

<a name=7.1></a>
### 7.1. Константы и переменные.

Грамматическое описание объявления поля и константы:

~~~~
КорневоеОбъявлениеПоля =
    МодификаторПоля {Пробел МодификаторПоля} Пробел
    ОбъявлениеПоля Пробел
    Идентификатор {ПробельныйСимвол}
    СимволПрисвоение {ПробельныйСимвол}
    Выражение {ПробельныйСимвол} НоваяСтрока

КорневоеОбъявлениеКонстанты =
    МодификаторПоля {Пробел МодификаторПоля} Пробел
    ОбъявлениеКонстанты Пробел
    Идентификатор {ПробельныйСимвол}
    СимволПрисвоение {ПробельныйСимвол}
    Выражение {ПробельныйСимвол} НоваяСтрока
~~~~

Синтаксис объявления поля:

~~~~
[<Модификаторы>] поле <Идентификатор> = <Выражение>
~~~~

Синтаксис объявления константы:

~~~~
[<Модификаторы>] конст <Идентификатор> = <Выражение>
~~~~

Объявление переменной или константы модуля.

Для константы применяется ключевое слово "конст", для переменной ключевое слово "поле".

Любая константа и переменная должна быть проинициализирована. Тип константы или переменной можно однозначно вывести из правой части присвоения.

Модификаторы полей и констант описаны в главе [7.1.1. Модификаторы поля](#7.1.1).

Пример:

~~~~
поле а = НОД(36, 24) // Зависит от типа, который возвращает метод НОД
конст б = (3 + 5) !0 // Тип Целое.
~~~~

<a name=7.1.1></a>
#### 7.1.1. Модификаторы поля.

Грамматическое описание модификаторов поля:

~~~~
МодификаторПоля =
    МодификаторСтат | МодификаторДинамическое |
    МодификаторЗакрытое | МодификаторЗащищённое | МодификаторОткрытое
~~~~

Если поле класса имеет следующие модификаторы.

Модификаторы статичности:
* стат - статическое. Одно поле, создаваемое для всех экземпляров класса.
* динамическое - динамическое поле. Для каждого экземпляра класса создаётся свой экземпляр поля. (значение по-умолчанию)

Модификаторы области видимости:
* закрытое - видимо только внутри класса (значение по-умолчанию)
* защищённое - видимо внутри класса и его наследников.
* открытое - видимо всем.

Каждый из блоков модификаторов может встречаться только один раз. В версии 0.1 реализована только комбинация модификаторов "стат закрытое". Остальные комбинации выдают ошибку.

<a name=7.2></a>
### 7.2. Методы (функции).

Грамматическое описание объявления поля и константы:

~~~~
КорневоеОбъявлениеМетода =
    МодификаторМетода {Пробел МодификаторМетода} Пробел
    ОбъявлениеМетода Пробел
    Идентификатор

    ОткрывающаясяСкобка {ПробельныйСимвол}
    [
    Выражение Пробел Идентификатор {ПробельныйСимвол}
    {
    Запятая {ПробельныйСимвол}
    Выражение Пробел Идентификатор {ПробельныйСимвол}
    }
    ]
    ЗакрывающаясяСкобка

    Выражение {ПробельныйСимвол}
    СимволДвоеточие {ПробельныйСимвол} НоваяСтрока

    СтрокаБлока{СтрокаБлока}
~~~~

Синтаксис:

~~~~
[<Модификаторы>] метод <ИмяМетода>([<Тип> <Идентификатор> [, <Тип> <Идентификатор>]* ]) [<ВыходнойТип>]:
    <Алгоритм>
~~~~

Заголовок метода состоит из следующих друг за другом частей:

- Сначала следуют модификаторы метода.
- Затем ключевое слово "метод"
- Затем имя метода
- Затем в скобках перечисление входных переменных или пустые скобки, если у метода нет параметров.
- Затем тип возвращаемого значения, если метод возвращает результат
- Затем ставится двоеточие.

После заголовка, со следующей строки располагается тело метода (алгоритм метода). Алгоритм должен вернуть значение того типа, совпадающий с выходным типом. Если нет поля <ВыходнойТип>, то алгоритм не должен возращать никакого значения.

<a name=7.2.1></a>
#### 7.2.1. Модификаторы метода.

Грамматическое описание модификаторов метода:

~~~~
МодификаторПоля =
    МодификаторСтат | МодификаторДинамический |
    МодификаторЗакрытый | МодификаторЗащищённый | МодификаторОткрытый |
    МодификаторФинализируемый | МодификаторНаследуемый |
    МодификаторПерегруженный
~~~~

Модификаторы статичности:

* стат - статическая. Метод может работать только со статическими полями и методами класса.
* динамический - не статический метод. Метод может работать с динамическими полями и методами класса. (значение по-умолчанию)

Модификаторы области видимости:

* закрытый - видима только внутри класса (значение по-умолчанию)
* защищённый - видима внутри класса и его наследников.
* открытый - видима всем.

Модификаторы финализации:

* финализированный - финализированное. Метод запрещено перегружать в наследуемых классах. (значение по-умолчанию)
* наследуемый - не финализирована. Метод разрешено перегружать в наследуемых классах. (Сразу же становится динамическим методом.)

Модификатор перегруженности метода:

* перегруженный - обязательный модификатор, если метод перегружает родительский. В этом случае он также становится финализируемым по-умолчанию. Необходимо добавить в родительский метод модификатор "наследуемый", если от него будут наследоваться.

Каждый из блоков модификаторов может встречаться только один раз. В версии 0.1 реализована только комбинация модификаторов "стат закрытый финализированный". Остальные комбинации выдают ошибку.

<a name=7.2.2></a>
#### 7.2.2. Типы передаваемых данных.

Входные данные метода перечисляются через запятую, где сначала пишется тип переменной, а затем имя переменной. Пример:

~~~~
метод Обработать(Целое а, Строка с, Буль б) Буль:
~~~~

Передаваемые данные являются константными. То есть нельзя изменять эти переменные и поля в классе. Можно вызывать только константные методы. Константными методами называются те методы класса, которые не изменяются поля класса. Эти константные методы вычисляются компилятором.

~~~~
метод Сумма(Целое а, Целое б) Целое:
    вернуть а + б
~~~~

Если переменную надо изменить, то перед именем параметра метода ставится знак *. Например:

~~~~
метод Сумма(Целое *а, Целое б) Целое:
    а = а + 1
    вернуть а + б
~~~~

При вызове такого метода перед изменяемой переменной также ставится знак *. Пример:

~~~~
поле а = Сумма(*3, 5)
поле а = Сумма(*б, в)
~~~~

<a name=7.3></a>
### 7.3. Точка входа программы.

Любая исполняемая программа должна иметь точку входа. Это главный метод, с которого программа начинает свою работу. В языке Картарика такой метод называется `Запустить` и имеет одну из следующих сигнатур:

~~~~
стат метод Запустить():
стат метод Запустить() Целое:
~~~~

Такой метод должен быть единственным во всём проекте.

<a name=8></a>
## 8. Стандартная библиотека.

В этой главе описаны стандартные константы и методы, которые можно использовать в программе.

Пакеты `Кар.Типы` и `Кар` являются пакетами по-умолчанию, то есть нет необходимости писать весь путь к элементу полностью. Достаточно описать конкретные классы пакетов. Например:

~~~~
Кар.Консоль.Вывод(Кар.Типы.Целое8.Мин) // Полное описание.
Консоль.Вывод(Целое8.Мин) // Краткое описание.
~~~~

<a name=8.1></a>
### 8.1. Пакет Кар.Типы.

<a name=8.1.1></a>
#### 8.1.1. Класс Кар.Типы.Буль.

Пакет: `Кар.Типы`

Класс: `Буль`

<a name=8.1.2></a>
#### 8.1.2. Класс Кар.Типы.Целое8.

Пакет: `Кар.Типы`

Класс: `Целое8`

~~~~
стат конст Мин = Целое8(-128)
~~~~

Минимальное возможное число, которое можно записать в переменную типа Целое8.

~~~~
стат конст Макс = Целое8(127)
~~~~

Максимальное возможное число, которое можно записать в переменную типа Целое8.

<a name=8.1.3></a>
#### 8.1.3. Класс Кар.Типы.Целое16.

Пакет: `Кар.Типы`

Класс: `Целое16`

~~~~
стат конст Мин = Целое16(-32768)
~~~~

Минимальное возможное число, которое можно записать в переменную типа Целое16.

~~~~
стат конст Макс = Целое16(32767)
~~~~

Максимальное возможное число, которое можно записать в переменную типа Целое16.

<a name=8.1.4></a>
#### 8.1.4. Класс Кар.Типы.Целое32.

Пакет: `Кар.Типы`

Класс: `Целое32`

~~~~
стат конст Мин = Целое32(-2147483648)
~~~~

Минимальное возможное число, которое можно записать в переменную типа Целое32.

~~~~
стат конст Макс = Целое32(2147483647)
~~~~

Максимальное возможное число, которое можно записать в переменную типа Целое32.

<a name=8.1.5></a>
#### 8.1.5. Класс Кар.Типы.Целое64.

Пакет: `Кар.Типы`

Класс: `Целое64`

~~~~
стат конст Мин = Целое64(-9223372036854775808)
~~~~

Минимальное возможное число, которое можно записать в переменную типа Целое64.

~~~~
стат конст Макс = Целое64(9223372036854775807)
~~~~

Максимальное возможное число, которое можно записать в переменную типа Целое64.

<a name=8.1.6></a>
#### 8.1.6. Класс Кар.Типы.Целое.

Пакет: `Кар.Типы`

Класс: `Целое`

Является синонимом для класса `Кар.Типы.Целое32`.

<a name=8.1.7></a>
#### 8.1.7. Класс Кар.Типы.Счётное8.

Пакет: `Кар.Типы`

Класс: `Счётное8`

~~~~
стат конст Макс = Счётное8(255)
~~~~

Максимальное возможное число, которое можно записать в переменную типа Счётное8.

<a name=8.1.8></a>
#### 8.1.8. Класс Кар.Типы.Счётное16.

Пакет: `Кар.Типы`

Класс: `Счётное16`

~~~~
стат конст Макс = Счётное16(65535)
~~~~

Максимальное возможное число, которое можно записать в переменную типа Счётное16.

<a name=8.1.9></a>
#### 8.1.9. Класс Кар.Типы.Счётное32.

Пакет: `Кар.Типы`

Класс: `Счётное32`

~~~~
стат конст Макс = Счётное32(4294967295)
~~~~

Максимальное возможное число, которое можно записать в переменную типа Счётное32.

<a name=8.1.10></a>
#### 8.1.10. Класс Кар.Типы.Счётное64.

Пакет: `Кар.Типы`

Класс: `Счётное64`

~~~~
стат конст Макс = Счётное64(18446744073709551615)
~~~~

Максимальное возможное число, которое можно записать в переменную типа Счётное64.

<a name=8.1.11></a>
#### 8.1.11. Класс Кар.Типы.Счётное.

Пакет: `Кар.Типы`

Класс: `Счётное`

Является синонимом для класса `Кар.Типы.Счётное32`.

<a name=8.1.12></a>
#### 8.1.12. Класс Кар.Типы.Дробное32.

Пакет: `Кар.Типы`

Класс: `Дробное32`

~~~~
стат конст БитыЭкспоненты = 7
~~~~

Количество бит, выделенных для экспоненты.

~~~~
стат конст БитыМантиссы = 24
~~~~

Количество бит, выделенных для мантиссы.

~~~~
стат конст ЭкспонентаМин = -125
~~~~

Минимальное значение экспоненты, которое генерирует нормализованное число с плавающей точкой .

~~~~
стат конст ЭкспонентаМакс = 128
~~~~

Максимальное значение экспоненты, которое генерирует нормализованное число с плавающей точкой .

~~~~
стат конст Мин = Дробное32(1.17549с-38)
~~~~

Минимальное положительное число, которое можно записать в переменную типа Дробное32.

~~~~
стат конст Макс = Дробное32(3.40282с+38)
~~~~

Максимальное положительное число, которое можно записать в переменную типа Дробное32.

~~~~
стат конст Эпсилон = Дробное32(1.19209с-07)
~~~~

Разница между 1 и минимальным значением, большим единицы, которое может быть представлено типом Дробное32.

<a name=8.1.13></a>
#### 8.1.13. Класс Кар.Типы.Дробное64.

Пакет: `Кар.Типы`

Класс: `Дробное64`

~~~~
стат конст БитыЭкспоненты = 10
~~~~

Количество бит, выделенных для экспоненты.

~~~~
стат конст БитыМантиссы = 53
~~~~

Количество бит, выделенных для мантиссы.

~~~~
стат конст ЭкспонентаМин = -1021
~~~~

Минимальное значение экспоненты, которое генерирует нормализованное число с плавающей точкой .

~~~~
стат конст ЭкспонентаМакс = 1024
~~~~

Максимальное значение экспоненты, которое генерирует нормализованное число с плавающей точкой .

~~~~
стат конст Мин = Дробное64(2.22507с-308)
~~~~

Минимальное положительное число, которое можно записать в переменную типа Дробное64.

~~~~
стат конст Макс = Дробное64(1.79769с+308)
~~~~

Максимальное положительное число, которое можно записать в переменную типа Дробное64.

~~~~
стат конст Эпсилон = Дробное64(2.22045с-16)
~~~~

Разница между 1 и минимальным значением, большим единицы, которое может быть представлено типом Дробное64.

<a name=8.1.14></a>
#### 8.1.14. Класс Кар.Типы.Дробное.

Пакет: `Кар.Типы`

Класс: `Дробное`

Является синонимом для класса `Кар.Типы.Дробное64`.

<a name=8.1.15></a>
#### 8.1.15. Класс Кар.Типы.Строка.

Пакет: `Кар.Типы`

Класс: `Строка`

~~~~
метод Длина() Счётное
~~~~

Возвращает количество символов строки без учёта завершающего нулевого символа.

~~~~
метод Найти(Строка подстрока) Счётное?
~~~~

Находит позицию первого вхождения подстроки для данной строки. Если подстрока не встречается в данной строке, возвращается значение Пусто.

~~~~
метод НайтиСПозиции(Счётное позиция, Строка подстрока) Счётное?
~~~~

Находит позицию первого вхождения подстроки для данной строки, начиная с данной позиции. Если подстрока не встречается в данной строке после позиции, возвращается значение Пусто.

~~~~
метод Подстрока(Счётное позиция, Счётное длина) Строка
~~~~

Возвращает подстроку данной строки начиная с заданной позиции и заданной длины.
Если `позиция` больше, чем длина строки, то возвращает пустую строку.
Если `позиция + длина` больше, чем длина строки, возвращает подстроку от заданной позиции до конца строки.

<a name=8.1.16></a>
#### 8.1.16. Шаблон класса Кар.Типы.Неопределённость.

Пакет: `Кар.Типы`

Класс: `Неопределённость`

~~~~
метод ПустойЛи() Буль
~~~~

Проверяет, явлется ли неопределённость пустой.

<a name=8.2></a>
### 8.2. Пакет Кар.

<a name=8.2.1></a>
#### 8.2.1. Класс Кар.Консоль.

Пакет: `Кар`

Класс: `Консоль`

~~~~
метод Ввод() Строка
~~~~

Возвращает строку из потока. Если это невозможно, возвращает значение Пусто.

~~~~
метод Вывод(Буль значение)
метод Вывод(Целое8 значение)
метод Вывод(Целое16 значение)
метод Вывод(Целое32 значение)
метод Вывод(Целое64 значение)
метод Вывод(Целое значение)
метод Вывод(Счётное8 значение)
метод Вывод(Счётное16 значение)
метод Вывод(Счётное32 значение)
метод Вывод(Счётное64 значение)
метод Вывод(Счётное значение)
метод Вывод(Дробное32 значение)
метод Вывод(Дробное64 значение)
метод Вывод(Дробное значение)
метод Вывод(Строка значение)
~~~~

Выводит значение переменной на экран. Для параметра с типом строки выводит строку в поток. Для остальных типов, они переводятся в строку и выводят получившуюся строку в поток.

<a name=8.2.2></a>
#### 8.2.2. Класс Кар.ПотокОшибок.

~~~~
метод Вывод(Буль значение)
метод Вывод(Целое8 значение)
метод Вывод(Целое16 значение)
метод Вывод(Целое32 значение)
метод Вывод(Целое64 значение)
метод Вывод(Целое значение)
метод Вывод(Счётное8 значение)
метод Вывод(Счётное16 значение)
метод Вывод(Счётное32 значение)
метод Вывод(Счётное64 значение)
метод Вывод(Счётное значение)
метод Вывод(Дробное32 значение)
метод Вывод(Дробное64 значение)
метод Вывод(Дробное значение)
метод Вывод(Строка значение)
~~~~

Выводит значение переменной на экран. Для параметра с типом строки выводит строку в поток. Для остальных типов, они переводятся в строку и выводят получившуюся строку в поток.

<a name=8.2.3></a>
#### 8.2.3. Класс Кар.Мат.

Пакет: `Кар`

Класс: `Мат`

~~~~
стат метод ВзятьПСЧ(Счётное значение) Счётное
~~~~

Возвращает следующее псевдослучайное число по формуле: `значение = значение + значение влево 7 + значение влево 16 + 12345`.

~~~~
стат метод ВзятьСлучайное() Счётное
~~~~

Возвращает случайное число.

