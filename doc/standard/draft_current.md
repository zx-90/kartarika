# Стандарт. Картарский язык программирования. Версия 0.1. [Черновик]

## Оглавление.

[0. Введение.](#0)

[1. Общие принципы.](#1)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[1.1. Пример кода.](#1.1)

[](#){name=0}
## 0. Введение.

[](#){name=1}
## 1. Общие принципы.

[](#){name=1.1}
### 1.1. Пример кода.

Вот пример простейшей программы, которая выводит на экран сообщение "Привет, мир!".

~~~~
стат метод Запустить() Целое:
	Кар.Печатать("Привет, мир!\н")
	вернуть 0
~~~~
Данный текст программы должен быть записан в кодировке UTF-8 и помещен в файл с раширением "кар", например: ПриветМир.кар. Далее его можно откомпилировать с помощью программы

~~~~
kar ПриветМир -o hello.exe
~~~~

и запустить из командной строки

~~~~
hello.exe
~~~~

После запуска программа выведен на экран строку "Привет, мир!".

### 1.2. Общее описание языка.

Язык программирования Картарика или Картарский язык является строго-типизированным объектно-ориентированным языком с обязательной инициализацией переменных с ограниченным сборщиком мусора и запретом кольцевых зависимостей.

(??? Дать ссылку на раздел, описывающий запрет кольцевых зависимостей.)

#### 1.2.4. Внешние ссылки.

Если в одном модуле необходима ссылка на другой модуль, то он записывается в виде пути и имени файла (без расширения), разделенных точкой. В настоящее время модулем может быть модуль из стандартной библиотеки. Например, если модуль с именем `Модуль.кар` лежит в каталоге `Каталог1`, который в свою очередь лежит в каталоге `Каталог2`, то путь к модулю записывается так: `Каталог2.Каталог1.Модуль`.

Алгоритм поиска модуля. При поиске модуля программа пытается найти модуль в текущем каталоге, затем в каталоге проекта, затем в каталоге библиотек, затем в каталоге стандартной библиотеки.

В сообщениях об ошибках или в других случаях, когда нужно однозначно описать какой конкретно модуль имеется в виду можно написать:

~~~~
Стандарт:Модуль.Подмодуль
Библиотека.<ИмяБиблиотеки>.<ВерсияБиблиотеки>:Модуль.Подмодуль
Проект:Модуль.Подмодуль
~~~~

### 1.3. Общая структура проекта.

Файловая структура проекта. Проект состоит из одного модуля. Результатом компиляции модуля является исполняемая программа.

В модулях записывается непосредственно код программы.

В картарском языке модуль = файл = класс.

Файл модуля имеет расширение кар. Имя файла (без расширения) должен соответствовать правилам токена (см. ???).

Подробное описание синтаксиса модулей смотри в ???.

### 1.4. Юникод и кодировка.

Написанные программы используют ЮНИКОД версии 14.0 (UNICODE 14.0) , описание которого можно найти на сайте

[http://www.unicode.org](http://www.unicode.org)

Используемая кодировка: UTF-8. Соответствующий стандарт находится здесь:

[https://tools.ietf.org/rfc/rfc3629.txt](https://tools.ietf.org/rfc/rfc3629.txt)

## 2. Лексическая структура модуля.

### 2.1. Грамматика.

(???) Это относится скорее ко второй главе. Лексическая структура модуля.

Для описания грамматики используется расширенная форма Бэкуса-Наура, с некоторыми дополнениями.

Описание отдельных символов:

* Переменная, состоящая из одного символа, обозначает этот символ. Например: ф - русская буква ф, z - латинская буква z и т.д.
* Для различения похожих букв русского и английского алфавита, там где не понятен контекст, перед русской буквой ставится префикс р (русский), перед английской буквой ставится префикс l (latin). Например ра обозначает русскую букву а, la - обозначает латинскую букву a.
* Переменной "юникод" обозначается любой символ Юникода.
* Переменной "буква" обозначается любая буква любого алфавита Юникода.
* Символ Юникода также можно записать в виде \uHEX. То есть значала записывается обратная косая черта, затем английская буква u и после неё номер символа в таблицце Юникода в шестнадцатеричном формате. Например \u5F обозначает символ нижнего подчеркивания.

Правила записи расширенной формы Бэкуса-Наура, используемые в этом документе:

* Конкатенация. Конкатенируемые символы заключены в двойные кавычки. Правило вида A = "BCD". обозначает, что нетерминал A состоит из трех символов — B, C и D.
* Выбор. Обозначается вертикальной чертой. Правило вида A = B|C|D. Обозначает, что нетерминал A может состоять либо из B, либо из C, либо из D.
* Для сокращения записи выбора, если символы стоят рядом в таблице Юникод, можно обозначить промежуток символом тире. Правило вида 1-3. Обозначает либо 1, либо 2, либо 3.
* Кроме. Исключения в выборе обозначается восклицаетльным знаком. Правило 0-9!3!5 обозначает все цифры от 0 до 9, кроме 3 и 5. То есть 0, 1, 2, 4, 6, 7, 8, 9.
* Условное вхождение. Квадратные скобки выделяют необязательный элемент выражения, который может присутствовать, а может и отсутствовать. Правило вида A = [B]. обозначает, что нетерминал A либо является пустым, либо состоит из символа B.
* Повторение. Фигурные скобки обозначают конкатенацию любого числа (включая нуль) записанных в ней элементов. Правило вида A = {B}. обозначает, что A — либо пустой, либо представляет собой конкатенацию любого числа символов B (то есть A — это либо пустой элемент, либо B, либо BB, либо BBB и так далее). Если требуется, чтобы A представлял собой либо B, либо произвольное число B, но не мог быть пустым, используется запись A = B{B}.
* Круглые скобки. Они применяются для группировки элементов при формировании сложных выражений. Например, правило A = (B|C)(D|E). обозначает, что A состоит из двух символов, первым из которых является либо B, либо C, вторым — либо D, либо E, то есть A может быть одной из цепочек BD, BE, CD, CE.

### 2.1. Конец строки.

Грамматическое описание конца строки:

~~~~
КонецСтроки = (\u0A)|(\u0D \u0A)
~~~~

Конец строки может быть либо символов перевода строки либо сочетанием символов возврата каретки и перевода строки (\n или \r\n в обозначении языков с С-подобным синтаксисом).

### 2.2. Комментарии.

Комментарии могут быть однострочными и многострочными.

Грамматическое описание однострочного комментария:

~~~~
ОднострочныйКомментарий = "//" {Юникод!КонецСтроки}
~~~~

Перед началом однострочного комментария ставится удвоенный символ "/" послечего идёт любая последовательность символов до символов конца строки.

Грамматическое описание многострочного комментария:

~~~~
Многострочный комментарий = "/*" {Юникод!"!"} "*/"
~~~~

Многострочный комментарий заключен в символы "/*" и "*/" внутри которого может быть любая комбинация текстовых символов за исключением последовательности "*/".

Комментарий можно поставить в любое место, где можно поставить пробельный символ.

### 2.3. Пробелы.

Грамматическое описание пробельных символов:
~~~~
ПробельныйСимвол = \u20 | \u09 | Комментарий
Пробел = ПробельныйСимвол{ПробельныйСимвол}
~~~~

Пробел состоит из одного или более пробельных символов. Пробельным символом является символ пробела или символ горизонтальной табуляции.

В начале строки Пробел выполняет также дополнительную функцию определения к какому блоку принадлежит строка. Один символ горизонтальной табуляции является табуляцией длиной в четыре пробела, комментарий - пробельный сисмвол длиной в ноль пробелов.
(??? Возможно нужен отдельный раздел для описания блоков.)

### 2.4. Ключевые слова.

(??? добавить список ключевых слов из последующих глав: числа, поля, пусто, модификаторы полей и методов, модификаторы для класса и т.д. и т.п.)

~~~~
КлючевоеСлово = "Целое8" | "Целое16" | "Целое32" ... ( и т.д.)
~~~~

### 2.5. Идентификаторы.

Грамматическое описание идентификатора:

~~~~
Буква = а-я | a-z | _
Цифра = 0-9
Идентификатор = (Буква{Буква | Цифра})!КлючевоеСлово
~~~~

Идентификатор - это набор букв и цифр неограниченной длины, начинающийся с буквы. Набор букв и цифр не должен совпадать с ключевыми словами.

В одном идентификаторе нельзя одновременно использовать русские и английские символы (??? Нужно ли такое условие).

### 2.6. Литералы.

#### 2.6.1. Целые числа.

Грамматическое описание:

~~~~
Цифра = 0-9
Знак = + | -
ЦелоеЧисло = [Знак] Цифра{Цифра}
~~~~

Вначале целого числа может стоять знак "+" или "-". Далее идет набор цифр от 0 до 9.

#### 2.6.2. Цифра в шестнадцатиричном формате.

Грамматическое описание:

~~~~
ШестнадцатиричнаяЦифра = 0-9 | А | Б | В | Г | Д | Е
ШестнадцатиричноеЧисло = "0ш" ШестнадцатиричнаяЦифра{ШестнадцатиричнаяЦифра}
~~~~

Шестнадцатиричное число начинается с символов 0ш а затем идут одна или несколько шестнадцатиричных цифр: от нуля до девяти и далее A=10, Б=11, В=12, Г=13, Д=14, Е=15. Буквы могут быть как заглавные, так и маленькие.

??? Выглядит трешово, конечно. Другие варианты обсуждаемы. Вообще нужны ли шестнадцатиричные цифры? И как насчет двоичных и восмеричных чисел? Нужен ли знак перед началом числа?

#### 2.6.3. Числа с плавающей точкой.

Грамматическое описание:

~~~~
НеЧисло = "НеЧисло"

ПлюсБесконечность = "Бесконечность" | "ПлюсБесконечность"
МинусБесконечность = "МинусБесконечность"

Цифра = 0-9
Точка = \u2E
Знак = + | -
ОбычнаяЗаписьДробного = [Знак] Цифра{Цифра} Точка Цифра{Цифра}

Экспонента = "с" | "С"
ЭкспоненциальнаяЗаписьДробного = ОбычнаяЗаписьДробного Экспонента ЦелоеЧисло
~~~~

Существует два основных типа записи чисел с плавающей точкой: обычная запись и экспоненциальная запись.

В обычной записи числа с плавающей точкой в начале может стоять знак "+" или "-". Далее идет набор цифр от 0 до 9, обозначающий целую часть числа, затем символ ".", затем цифры от 0 до 9, обозначающие дробную часть числа.

В экспоненциальной записи сначала идет мантисса, которая записывается как обычная запись числа, затем символ "с" или "С" разделяющее мантиссу и экспоненту, затем целое число, обозначающее экспоненту.

Кроме того, для особых значений чисел с плавающей точкой применяются ключевые слова "НеЧисло", "Бесконечность", "ПлюсБесконечность" и "МинусБесконечность".

Примечание. Знак, разделяющий мантиссу и экспоненту взяли "с" вместо "э", так как символ "э" находится скраю клавиатуры, поэтому "с" будет удобнее для набора. Под "с" имеется в виду слово "степень".

#### 2.6.4. Булевы значения.

Грамматическое описание:

~~~~
БулевоЗначение = "Да" | "Нет"
~~~~

Булево значение может принимать одно из двух значений "Да" или "Нет", соответствующие булевым значениям "Правда" и "Ложь" соответственно.

#### 2.6.5. Строковые литералы.

Грамматическое описание:

~~~~
ДвойныеКавычки = \u22
СимволИсключения = \u5C
СтрочныйСимвол = Юникод!ДвойныеКавычки!СимволИсключения
Строка = ДвойныеКавычки {СтрочныйСимвол | ИсключающиеСимволы} ДвойныеКавычки
~~~~

Двойные кавычки используются для обозначения строкового литерала. Внутри могут стоять любые символы кроме символа двойной кавычки и символа исключения. Символ исключения используется для создания исключающих символов, описанных в (??? ссылка на следующий пункт.)

#### 2.6.6. Исключающие символы для строковых литералов.

Грамматическое описание:

~~~~
СимволИсключения = \u5C
СимволВозвратаКаретки = СимволИсключения к
СимволНовойСтроки = СимволИсключения н
СимволГоризонтальнойТабуляции = СимволИсключения т
СимволДвойныхКавычек = СимволИсключения ДвойныеКавычки
СимволОбратногоСлеша = СимволИсключения СимволИсключения
ИсключающиеСимволы = СимволНовойСтроки | СимволГоризонтальнойТабуляции | СимволДвойныхКавычек | СимволОбратногоСлеша
~~~~

В строке можно записать сивол новой строки или сивол табуляции, напрямую написав их внутри строки или добавив сочетание сиволов "\н" или "\т" соответственно. Если необходимо добавить двойные кавычки внутри строки, необходимо добавить в строку сочетание "\"". Для добавления обратного слеша, необходимо просто его удвоить: "\\".

Также можно добавить юникод-символы, записав их шестнадцатиричные коды с помощью исключающего символа "\ш". Сначала пишется ключевое буквосочетание "\ш", затем пишутся шестнадцатиричный код символа. Можно написать сразу несколько кодов, для этого их надо писать через запятую. По окончании записи юникод-символов ставится пробел, либо любой другой символ, не использующийся в написании шестнадцатиричного символа. Если в конце шестнадцатиричных символов ставится пробел, то он съедается.

Пример:

~~~~
"Маленькая греческая буква альфа \ш3Б1"
"Маленькие греческие буквы альфа и бетта \ш3Б1,3Б2  22"
~~~~

Конечное преобразование этих строк будет таким:

~~~~
"Маленькая греческая буква альфа α"
"Маленькие греческие буквы альфа и бетта αβ 22"
~~~~

Обратите внимание, что в конце второй строки перед символами "22" два пробела. Первый из них обозначает конец исключающего символа "\ш" и как бы "съедается". Второй пробел остаётся.

#### 2.6.7. разделители.

Грамматическое описание:

~~~~
ОткрывающиесяСкобки = \u28
ЗакрывающиесяСкобки = \u29
Запятая = \u2C
~~~~

#### 2.6.8. операторы.

Следующие токены являются операторами:

~~~~
!"№;%:?*() ., -_=+\/*

Плюс = \u2B
Минус = \u2D
Умножить = \u2A
Разделить = \u2F
Присвоение = \u3D
Точка = \u2E
Двоеточие= \u3A

Равно = "=="
НеРавно = "!="
Больше = "больше"
Меньше = "меньше"
БольшеИлиРавно = "бир"
МеньшеИлиРавно = "мир"
~~~~

### 2.7. Входные элементы и токены.

??? Здесь должно быть общее синтаксическое описание всего модуля.

## 3. Логическая структура модуля.

### 3.1. Строки модуля.

Фактически модуль разбивается на строки. Понятие строки модуля и строки текстового файла близки, но всё же различаются.

Разница состоит в следующем. В текстовом файле разделение на строки всегда происходит с помощью символа новой строки (). При разбиении модуля на строки, символ новой строки может игнорироваться в двух случаях:

1. Если символ новой строки находится в комментарии, он игнорируется при разбиении модуля на строки.

2. Внутри круглых скобок символ новой строки также игнорируется.

Поэтому существует 2 способа разбить строку модуля на несколько строк текстового файла:

1 способ. Комментарий сильнее символа новой строки. Это означает, что в любом месте, где разрешен пробельный символ можно с помощью комментария разделить одну строку на две. Например:

~~~~
поле Количество = /*

*/ 5
~~~~

2 способ. Скобки сильнее символа новой строки. Это означает, что внутри любой круглой скобки, везде, где разрешен пробельный символ можно добавить символ новой строки:

~~~~
стат метод ПосчитатьСумму(
    Целое Слагаемое1,
    Целое Слагаемое2
) Целое:
~~~~

### 3.2. Пустые строки модуля.

После раделения модуля на строки, пустые строки игнорируются. Пустые строки это строки модуля, которые состоят только из пробельных символов (то есть символов пробела, табуляции и комментариев).

### 3.3. Корневые элементы.

На более высоком уровне модуль делится на корневые элементы. Корневой элемент может либо состоять из одной строки модуля, либо из множевства строк. Если корневой элемент состоит из множества строк модуля, то он имеет блоковую структуру. Описание блоковой структуры смотри в пункте (??? ссылка).

Также для описания корневых элементов необходимо ввести понятие (арифметического) выражения и алгоритма. Арифметические выражения описаны в главе (??? ссылка). Алгоритм описан в главе (??? ссылка).

Корневые элементы могут быть разными по структуре и иметь различную функциональность. Более подробно все корневые элементы описаны в главе (??? ссылка).

### 3.4. Блоки.

Блок состоит из более чем одной строки, блоки могут быть вложенные. Общая лексическая структура такова:

~~~~
<Отступ блока верхнего уровня><Описание блока>:
<Отступ блока верхнего уровня><Отступ блока><Строка модуля>
<Отступ блока верхнего уровня><Отступ блока><Строка модуля>
...
<Отступ блока верхнего уровня><Отступ блока><Строка модуля>
~~~~

Так как блоки могут быть вложенными, то при описании блока каждая его строка должна начинаться с отступа блока более вержнего уровня. В первой строке идёт описание блока, заканчивающееся двоеточием. Последующие строки модуля внутри блока называются телом блока. Тело блока состоит из строк модуля в каждом из которые поставлены одинаковые отступы и затем после отступов написаны строки модуля.

Отступы состоят из пробелов и табуляций. Один символ табуляции эквивалентен 4 символам пробела. Отступ блока может состоять из любого ненулевого количества пробелов. У корневых блоков модуля отступ равен 0 символов. У блоков более нижнего уровня отступ всегда больше чем у блоков верхнего уровня.

Любая строка модуля в свою очередь также может быть блоком, со своим описанием и телом блока, но уже с большим отступом, чем родительский блок. После окончания блока идут строковые описания блока верхнего уровня с отступами блока верхнего уровня.

Существует также вырожденный случай, когда блок может быть пустым. В этом случае он оформляется следующим образом:

~~~~
<Отступ блока верхнего уровня><Описание блока>:
<Отступ блока верхнего уровня><Отступ блока>пропустить
~~~~

То есть тело блока должно состоять из одной непустой строки модуля, с ключевым словом "пропустить".

### 3.5. Пример.

Пример программы:

~~~~
стат метод Запустить() Целое:
	конст КоличествоПараметров = 3
                          // Пустая строка. Здесь может быть сколько угодно пробелов и комментов.
	если (Параметры.Длина не равно КоличествоПараметров):
		Ат.Печатать("Количество параметров программы должно быть равно 3.%н")

~~~~

В данном примере первая строка описывает блок "метод" с именем запустить. Внутри блока метода находится строковое выражение, описывающее константу, пустая строка и далее вложенный блок "если".

## 4. Типы данных.

Картарский язык программирования - это строго типизированный язык. Это означает, что каждая переменная и выражение имеет свой тип, известный на этапе компиляции.

### 4.1. Простые типы данных

Простые типы данных делятся на беззнаковые целые, знаковые целые, числа с плавающей точкой, булевы выражения и перечисления.

#### 4.1.1. Целые числа.

Ряд типов для знаковых целых чисел:

* Целое8 - 8-ми битное знаковое целое число. Принимает целочисленные значения от -128 до 127 включительно.
* Целое16 - 16-ти битное знаковое целое число. Принимает целочисленные значения от -32768 до 32767 включительно.
* Целое32 - 32-ти битное знаковое целое число. Принимает целочисленные значения от -2147483648 до 2147483647 включительно.
* Целое64 - 64-ти битное знаковое целое число. Принимает целочисленные значения от -9223372036854775808 до 9223372036854775807 включительно.
* Целое - синоним для типа Целое32.

Ряд типов для беззнаковых целых чисел:

* Счётное8 - 8-ми битное беззнаковое целое число. Принимает целочисленные значения от 0 до 255 включительно.
* Счётное16 - 16-ми битное беззнаковое целое число. Принимает целочисленные значения от 0 до 65535 включительно.
* Счётное32 - 32-ми битное беззнаковое целое число. Принимает целочисленные значения от 0 до 4294967295 включительно.
* Счётное64 - 64-ми битное беззнаковое целое число. Принимает целочисленные значения от 0 до 18446744073709551615 включительно.
* Счётное - синоним для типа Счётное32.

#### 4.1.2. Числа с плавающей запятой.

Ряд типов для чисел с плавающей запятой:

* Дробное32 - числа с плавающей точкой одинарной точности (single precision) согласно стандарту IEEE Standard for Binary Floating-Point Arithmetic, ANSI/IEEE Standard 754-1985 (IEEE, New York).
* Дробное64 - числа с плавающей точкой двойной точности (double precision) согласно стандарту IEEE Standard for Binary Floating-Point Arithmetic, ANSI/IEEE Standard 754-1985 (IEEE, New York).
* Дробное - синоним для типа Дробное64.

#### 4.1.3. Булевый тип.

Булевый тип:

* Буль - булево число, принимающее одно из двух значений: "Да" или "Нет".

### 4.2. Ссылочные типы данных

#### 4.2.1. Строка.

Экземпляр класса "Строка" представляет набор символов Юникод. Строковый объект имеет константное (неизменяемое) значение. Строковые литералы ссылаются на экземпляры класса "Строка".

#### 4.2.2. Неопределенность.

Неопределенность - это тип данных, который модифицирует основной тип данных. Тип неопределенность может принимать либо специальное значение "Пусто", либо значение основного типа.

~~~~
поле Количество = Целое?(Пусто)
поле Цена = Целое?(35)
~~~~

Перевод из неопределенного типа в соответствующий ему определенный можно совершить с помощью вызова метода "или" (??? ссылка) или с помощью блока "раскрыть" (??? ссылка). Пример:

~~~~
поле Количество = Целое?(Пусто)

Кар.Напечатать(Количество.или(-1))

раскрыть Количество как Кол:
    Кар.Напечатать(Кол)
иначе:
    Кар.Напечатать("Количество не определено")
~~~~

(???) В примере блок "раскрыть" проверить на корректность написания.

## 5. Выражения.

### 5.1. Преобразование простых типов.

Все преобразования являются явными. Неявные преобразования запрещены.

Общий вид методов преобразования из типа Тип1 в тип Тип2 имеют один из следующих видов:

~~~~
открытый стат метод Тип2(Тип1 значение) Тип2
открытый стат метод Тип2(Тип1 значение) Тип2?
~~~~

Эта группа методов преобразует один простейший тип в другой. Возвращаемым значением может быть либо выходной тип, либо неопределенность выходного типа. Неопределенность появляется в преобразованиях между теми типами, которые не всегда могут быть однозначно преобразованы.

Пример преобразования типа Целое в тип Целое8:

~~~~
поле А = 45
поле Б = Целое8(А)
~~~~

#### 5.1.1. Преобразование из целого числа в целое число.

Общая формула преобразования:

~~~~
метод ЦелоеН(ЦелоеМ целое) ЦелоеН
~~~~

где буква М и Н обозначают одно из чисел: 8, 16, 32 или 64.

При преобразовании из меньшего в большее по разрядности число, старшие биты заполняются знаковым битом, то есть 0 для положительных чисел и 1 для отрицательных. При преобразовании из большего меньшее по разрядности число, старшие разряды просто удаляются.

Пример преобразования типа Целое в тип Целое8:

~~~~
поле А = 255
поле Б = Целое8(А) // Б = -1
~~~~

#### 5.1.2. Преобразование из счётного числа в целое число.

Общая формула преобразования:

~~~~
метод ЦелоеН(СчётноеМ счётное) ЦелоеН
~~~~

где буква М и Н обозначают одно из чисел: 8, 16, 32 или 64.

При преобразовании из меньшего в большее по разрядности число, старшие биты заполняются 0. При преобразовании из большего меньшее по разрядности число, старшие разряды просто удаляются.

Примеры преобразования:

~~~~
поле А = Счётное(255)
поле Б = Целое8(А) // Б = -1
поле В = Целое16(А) // В = 255
~~~~

#### 5.1.3. Преобразование из дробного числа в целое число.

Общая формула преобразования:

~~~~
метод ЦелоеН(ДробноеМ дробное) ЦелоеН?
~~~~

где буква М обозначает одно из чисел 32 или 64, а буква Н обозначает одно из чисел: 8, 16, 32 или 64.

Если число с плавающей точкой преобразуется в целое, то дробная часть отбрасывается (округление в сторону 0). Если значение целой части не может быть представлено целым типом (слишком большое значение дробного числа, либо дробное имеет значение Бесконечность/ПлюсБесконечность/МинусБесконечность, либо дробное имеет значение НеЧисло), то результат — не определён.

Примеры преобразования:

~~~~
поле А = Дробное(255.5)
поле Б = Целое8(А) // Б = Пусто
поле В = Целое16(А) // В = Целое16?(255)
~~~~

#### 5.1.4. Преобразование из строки в целое число.

Общая формула преобразования:

~~~~
метод ЦелоеН(Строка строка) ЦелоеН?
~~~~

где буква Н обозначает одно из чисел: 8, 16, 32 или 64.

Если строка представляет собой последовательность символов, как у литерала целого или шестнадцатеричного числа, то такая строка преобразуется в Целое число. В ином случае функция преобразования возвращает значение Пусто. Если значение числа записанное в строке не может вместиться в размер числа, то результатом преобразования также будет значение Пусто.

Примеры преобразования:

~~~~
поле строка1 = "123"
поле число1 = Целое(строка1) // число1 = Целое?(123)

поле строка2 = "-123"
поле число2 = Целое(строка2) // число2 = Целое?(-123)

поле строка3 = "123.1"
поле число3 = Целое(строка3) // число3 = Пусто
~~~~

#### 5.1.5. Преобразование из булева числа в целое число.

Общая формула преобразования:

~~~~
метод ЦелоеН(Буль буль) ЦелоеН
~~~~

где буква Н обозначает одно из чисел: 8, 16, 32 или 64.

Значение "Нет" преобразуется в число 0, значение "Да" преобразуется в число 1 для любого типа из линейки целых чисел.

Примеры преобразования:

~~~~
поле А = Целое(Нет) // А = 0
поле Б = Целое8(Да) // Б = 1
~~~~

#### 5.1.6. Преобразование из целого числа в счётное число.

Общая формула преобразования:

~~~~
метод СчётноеН(ЦелоеМ целое) СчётноеН
~~~~

где буква М и Н обозначают одно из чисел: 8, 16, 32 или 64.

При преобразовании из меньшего в большее по разрядности число, старшие биты заполняются знаковым битом, то есть 0 для положительных чисел и 1 для отрицательных. При преобразовании из большего меньшее по разрядности число, старшие разряды просто удаляются.

Пример преобразования типа Целое в тип Счётное8:

~~~~
поле А = -1
поле Б = Счётное8(А) // Б = 255
~~~~

#### 5.1.7. Преобразование из счётного числа в счётное число.

Общая формула преобразования:

~~~~
метод СчётноеН(СчётноеМ счётное) СчётноеН
~~~~

где буква М и Н обозначают одно из чисел: 8, 16, 32 или 64.

При преобразовании из меньшего в большее по разрядности число, старшие биты заполняются 0. При преобразовании из большего меньшее по разрядности число, старшие разряды просто удаляются.

Примеры преобразования:

~~~~
поле А = Счётное(256)
поле Б = Счётное8(А) // Б = 0
поле В = Счётное16(А) // В = 256
~~~~

#### 5.1.8. Преобразование из дробного числа в счётное число.

Общая формула преобразования:

~~~~
метод СчётноеН(ДробноеМ дробное) СчётноеН?
~~~~

где буква М обозначает одно из чисел 32 или 64, а буква Н обозначает одно из чисел: 8, 16, 32 или 64.

Если число с плавающей точкой преобразуется в счётное, то дробная часть отбрасывается (округление в сторону 0). Если значение целой части не может быть представлено счётным типом (слишком большое значение дробного числа, либо дробное имеет значение Бесконечность/ПлюсБесконечность/МинусБесконечность, либо дробное имеет значение НеЧисло), то результат — не определён.

Примеры преобразования:

~~~~
поле А = Дробное(256.5)
поле Б = Счётное8(А) // Б = Пусто
поле В = Счётное16(А) // В = Целое16?(255)
~~~~

#### 5.1.9. Преобразование из строки в счётное число.

Общая формула преобразования:

~~~~
метод СчётноеН(Строка строка) СчётноеН?
~~~~

где буква Н обозначает одно из чисел: 8, 16, 32 или 64.

Если строка представляет собой последовательность символов, как у литерала целого или шестнадцатеричного числа, то такая строка преобразуется в Счётное число. В ином случае функция преобразования возвращает значение Пусто. Если значение числа записанное в строке не может вместиться в размер числа, то результатом преобразования также будет значение Пусто.

Примеры преобразования:

~~~~
поле строка1 = "123"
поле число1 = Счётное(строка1) // число1 = Счётное?(123)

поле строка2 = "-123"
поле число2 = Счётное(строка2) // число2 = Счётное?(Пусто)

поле строка3 = "123.1"
поле число3 = Счётное(строка3) // число3 = Счётное?(Пусто)
~~~~

#### 5.1.10. Преобразование из булева числа в счётное число.

Общая формула преобразования:

~~~~
метод СчётноеН(Буль буль) СчётноеН
~~~~

где буква Н обозначает одно из чисел: 8, 16, 32 или 64.

Значение "Нет" преобразуется в число 0, значение "Да" преобразуется в число 1 для любого типа из линейки счётных чисел.

Примеры преобразования:

~~~~
поле А = Счётное(Нет) // А = 0
поле Б = Счётное8(Да) // Б = 1
~~~~

#### 5.1.11. Преобразование из целого числа в дробное число.

Общая формула преобразования:

~~~~
метод ДробноеН(ЦелоеМ целое) ДробноеН
~~~~

где буква М обозначает одно из чисел: 8, 16, 32 или 64, а Н - одно из чисел: 32 или 64.

Целое число преобразуется в дробное с учётом точности дробного числа.

Пример преобразования типа Целое в тип Дробное:

~~~~
поле А = -1
поле Б = Дробное(А) // Б = -1.0
~~~~

#### 5.1.12. Преобразование из счётного числа в дробное число.

Общая формула преобразования:

~~~~
метод ДробноеН(СчётноеМ счётное) ДробноеН
~~~~

где буква М обозначает одно из чисел: 8, 16, 32 или 64, а Н - одно из чисел: 32 или 64.

Счётное число преобразуется в дробное с учётом точности дробного числа.

Примеры преобразования:

~~~~
поле А = Счётное(256)
поле Б = Дробное(А) // Б = 256.0
~~~~

#### 5.1.13. Преобразование из дробного числа в дробное число.

Общая формула преобразования:

~~~~
метод ДробноеН(ДробноеМ дробное) ДробноеН
~~~~

где буквы М и Н обозначает одно из чисел 32 или 64.

Дробное число преобразуется в ближайшее возможное дробное число. Если дробное число преобразуется в дробное число меньшей точности и выходит за возможный ранг, то он преобразуется в значение ПлюсБесконечность или МинусБесконечность. 

Примеры преобразования:

~~~~
поле А = 256.5
поле Б = Дробное32(А) // Б = 256.5

поле В = ПлюсБесконечность
поле Г = Дробное32(В) // Г = ПлюсБесконечность
~~~~

#### 5.1.14. Преобразование из строки в дробное число.

Общая формула преобразования:

~~~~
метод ДробноеН(Строка строка) ДробноеН
~~~~

где буква Н обозначает одно из чисел 32 или 64.

Если строка представляет собой последовательность символов, как у литерала целого, шестнадцатеричного числа или числа с плавающей точкой, то такая строка преобразуется в Счётное число. В ином случае функция преобразования возвращает значение НеЧисло. Если значение числа записанное в строке не может вместиться в размер числа, то результатом преобразования будет значение ПлюсБесконечность или МинусБесконечность. Кроме того, есть слудющий правила:

* Знак, разделяющий целую и дробную часть может быть как точка (".") так и запятая (",").
* Дробное число со значением плюс бесконечность может быть записана следующими строковыми значениями: "∞", "+∞", "Бесконечность", "ПлюсБесконечность".
* Дробное число со значением минус бесконечность может быть записана следующими строковыми значениями: "-∞", "МинусБесконечность".

Примеры преобразования:

~~~~
поле строка1 = "123"
поле число1 = Дробное(строка1) // число1 = 123

поле строка2 = "-123"
поле число2 = Дробное(строка2) // число2 = -123

поле строка3 = "123.1"
поле число3 = Дробное(строка3) // число3 = 123.1
~~~~

#### 5.1.15. Преобразование из булева числа в дробное число.

Общая формула преобразования:

~~~~
метод ДробноеН(Буль буль) ДробноеН
~~~~

где буква Н обозначает одно из чисел 32 или 64.

Значение "Нет" преобразуется в число 0.0, значение "Да" преобразуется в число 1.0 для любого типа из линейки дробных чисел.

Примеры преобразования:

~~~~
поле А = Дробное(Нет) // А = 0.0
поле Б = Дробное32(Да) // Б = 1.0
~~~~

#### 5.1.16. Преобразование из целого числа в строку.

Общая формула преобразования:

~~~~
метод Строка(ЦелоеМ целое) Строка
~~~~

где буква М обозначает одно из чисел: 8, 16, 32 или 64.

Целое число преобразуется в строку. В начале строки может стоять знак минус для отрицательного числа, а затем следует последовательность цифр.

Пример преобразования типа Целое в тип Строка:

~~~~
поле А = -1
поле Б = Строка(А) // Б = "-1"
~~~~

#### 5.1.17. Преобразование из счётного числа строку.

Общая формула преобразования:

~~~~
метод Строка(СчётноеМ счётное) Строка
~~~~

где буква М обозначает одно из чисел: 8, 16, 32 или 64.

Счётное число преобразуется в строку. Преобразованная строка представляет собой последовательность цифр.

Примеры преобразования:

~~~~
поле А = Счётное(256)
поле Б = Строка(А) // Б = "256"
~~~~

#### 5.1.18. Преобразование из дробного числа строку.

Общая формула преобразования:

~~~~
метод Строка(ДробноеМ дробное) Строка
~~~~

где буква М обозначает одно из чисел 32 или 64.

Числа, чей модуль находится в пределах от 0.0001 до 10000 преобразуются в обычную запись числа с плавающей точкой. Если длина получившейся строки больше 10, то дробная часть обрезается справа так, чтобы общая длина строки вмещалась в 10 символов. Символ ".", отделяющий целую и дробную часть числа превращается в символ ",".

Если модуль преобразуемого числа меньше 0.0001 или больше 10000, то она преобразуется в экспоненциальную запись числа с плавающей точкой. Если длина получившейся строки больше 10, то дробная часть мантиссы обрезается справа так, чтобы общая длина строки вмещалась в 10 символов. Символ ".", отделяющий целую и дробную часть числа превращается в символ ",".

Если значение преобразуемого числа равно "НеЧисло", то оно преобразуется в строку "НеЧисло". Если значение равно плюс бесконечность, то оно преобразуется "∞", если значение равно минус бесконечность, то оно преобразуется в "-∞".

Примеры преобразования:

~~~~
поле А = 256.5
поле Б = Строка(А) // Б = "256.5"

поле В = ПлюсБесконечность
поле Г = Строка(В) // Г = "∞"
~~~~

#### 5.1.19. Преобразование из строки в строку.

Общая формула преобразования:

~~~~
метод Строка(Строка строка) Строка
~~~~

Фактически это копирование строки.

Примеры преобразования:

~~~~
поле строка1 = "АБВ"
поле строка2 = Строка(строка1) // строка2 = "АБВ"
~~~~

#### 5.1.20. Преобразование из булева числа в строку.

Общая формула преобразования:

~~~~
метод Строка(Буль буль) Строка
~~~~

Значение "Нет" преобразуется в строку "Нет", значение "Да" преобразуется в строку "Да".

Примеры преобразования:

~~~~
поле А = Строка(Нет) // А = "Нет"
поле Б = Строка(Да) // Б = "Да"
~~~~

#### 5.1.21. Преобразование из целого числа в булево число.

Общая формула преобразования:

~~~~
метод Буль(ЦелоеМ целое) Буль?
~~~~

где буква М обозначает одно из чисел: 8, 16, 32 или 64.

Если целое число равно 0, то оно преобразуется в булево значение "Нет". Если целое число равно 1, то оно преобразуется в булево значение "Да". В остальных случаях функция выдает значение Пусто.

Пример преобразования типа Целое в тип Буль:

~~~~
поле А = -1
поле Б = Буль(А) // Б = Пусто

поле В = 1
поле Г = Буль(В) // В = "Да"
~~~~

#### 5.1.22. Преобразование из счётного числа булево число.

Общая формула преобразования:

~~~~
метод Буль(СчётноеМ счётное) Буль?
~~~~

где буква М обозначает одно из чисел: 8, 16, 32 или 64.

Если счётное число равно 0, то оно преобразуется в булево значение "Нет". Если счётное число равно 1, то оно преобразуется в булево значение "Да". В остальных случаях функция выдает значение Пусто.

Примеры преобразования:

~~~~
поле А = Счётное(25)
поле Б = Буль(А) // Б = Пусто

поле В = Счётное(1)
поле Г = Буль(В) // В = "Да"
~~~~

#### 5.1.23. Преобразование из дробного числа булево число.

Общая формула преобразования:

~~~~
метод Буль(ДробноеМ дробное) Буль?
~~~~

где буква М обозначает одно из чисел 32 или 64.

Если дробное число равно 0.0, то оно преобразуется в булево значение "Нет". Если дробное число равно 1.0, то оно преобразуется в булево значение "Да". В остальных случаях функция выдает значение Пусто.

Примеры преобразования:

~~~~
поле А = 256.5
поле Б = Буль(А) // Б = Пусто

поле В = 1.0
поле Г = Буль(В) // Г = "Да"
~~~~

#### 5.1.24. Преобразование из строки в булево число.

Общая формула преобразования:

~~~~
метод Буль(Строка строка) Буль?
~~~~

В значения Да/Нет преобразуются следующие строковые пары: "1"/"0", "+"/"-", "Да"/"Нет", "д"/"н", "Yes"/"No", "Y"/"N". Каждая буква может быть записана в любом регистре. В остальных случаях функция возвращает значение Пусто.

Примеры преобразования:

~~~~
поле А = "дА"
поле Б = Буль(А) // Б = "Да"
~~~~

#### 5.1.25. Преобразование из булева числа в булево число.

Общая формула преобразования:

~~~~
метод Буль(Буль буль) Буль
~~~~

Фактически это копирование булевого значения.

Примеры преобразования:

~~~~
поле А = Буль(Нет) // А = "Нет"
поле Б = Буль(Да) // Б = "Да"
~~~~

### 5.2. Операция скобки (операция изменения приоритетов).

Операция скобок меняет приоритет выполнения операций.

### 5.3. Операция выбора элемента.

Операция выбора элемента обозначается через символ "." и необходим для выбора поля, метода или другого элемента класса.
(??? что такое другой элемент? Тесты можно вызывать?)

### 5.4. Операция обращения к методу.

~~~~
<Имя метода>([Параметр1 [, Параметр2 [..., ПараметрН]]])
~~~~

Операция обращения к методу обозначается через символ имя метода и последующим за ним круглых скобок. Внутри скобок перечисляются параметры метода, если они есть.

### 5.6. Операции неопределенности.

"?" - оператор, обозначающий неопределенность типа.
"!" - оператор разрешающий неопределенность.

Например:

~~~~
поле к = Целое?(Пусто)
...

Кар.Печатать(к ! 0)
~~~~

В этом примере печатается значение к или 0, если к имеет значение пусто.

### 5.8. Арифметические операции.

* "+" - унарный плюс
* "-" - унарный минус
* "+" - сложение
* "-" - вычитание
* "*" - умножение
* "*!" - защищенное умножение
* "/" - деление
* "/!" - защищенное деление
* "%" - остаток от деления
* "%!" - защищенный остаток от деления

Защищенное деление. Так как на ноль делить нельзя, то деление возвращает неопределенность Целое?. При защищенном делении если делитель равен нулю, то просто возвращает делимое. (??? Надо ли такое? Или луше возвращать единицу, или вообще убрать такое).

Для чисел в плавающей точкой из-за состояний бесконечности и не числа также необходимо ввести защищенное умножение. (??? Надо подробно расписать правила.)

Любая арифметическая операция выполняется над одинаковыми типами переменных. Если типы разные, используйте преобразование типов.

??? Возможно, нужно сделать аналоги в виде вызова методов для использования в шаблонах.

### 5.9. Битовые операции.

Операции только над числами и счётными (??? надо ли числа с плавающей запятой добавить?)

* би - побитовое и
* били - побитовое или
* билине - побитовое исключающее или
* бне - побитовое не

- операции выше выполняются только над числами/счетными одного и того же типа.

* вправо - битовый сдвиг вправо
* влево - битовый сдвиг влево

1 вправо 2

Здесь левая и правая часть может быть разных типов. возвращает тот же тип что и у числа слева.

??? Возможно стоит добавить функции для чисел Установить(Целое бит), Снять(Целое бит) и Инвертировать(Целое бит).

??? Возможно, нужно сделать аналоги в виде вызова методов для использования в шаблонах.

### 5.10. Логические операции.

* == - проверка на равенство.
* != - не равно
* больше - больше
* бир - больше или равно
* меньше - меньше
* мир - меньше или равно

Любая арифметическая операция выполняется над одинаковыми типами переменных. Если типы разные, используйте преобразование типов.

* и - логическое и
* или - логическое или
* не - логическое не

и, или, не - выполняются только над булевыми типами.

??? Возможно, нужно сделать аналоги в виде вызова методов для использования в шаблонах.

### 5.11. Операции со строками.

* "+" - конкатенация

методы строк:

Строка.Длина() счётное - длина строки в символах

Строка.Размер() счётное - длина строки в байтах

Строка.Символ(Целое ч) символ? - возвращает символ по номеру.

??? Возможно, нужно сделать аналоги в виде вызова методов для использования в шаблонах.

### 5.12. Приоритет операций.

Ниже описан приоритет операций а также ассоциативность.

|Приоритет|Операция|Ассоциативность|Описание|
|---------|:------:|---------------|--------|
|1|()|слева направо|изменение приоритета операции, параметры при вызове метода, преобразование типов|
|2|. .метод(,,)|слева направо|обращение к элементу, вызов метода|
|3|?||неопределенность|
|4|!|слева направо|разрешение неопределенности|
|5|+ - не бне||унарный плюс, унарный минус, логическое НЕ, побитовое НЕ|
|6|* *! / /! % %!|слева направо|умножение, защищенное умножение, деление, защищенное деление, остаток от деления, защищенный остаток от деления|
|7|+ -|слева направо|сложение, вычитание|
|8|вправо влево|слева направо|сдвиг вправо, сдвиг влево|
|9|больше бир меньше мир|слева направо|больше, больше или равно, меньше, меньше или равно|
|10|== !=|слева направо|равно, не равно|
|11|би|слева направо|побитовое И|
|12|билине|слева направо|побитовое исключающее ИЛИ|
|13|били|слева направо|побитовое ИЛИ|
|14|и|слева направо|логическое И|
|15|или|слева направо|логическое ИЛИ|

??? Кроме вызова метода (оператор .метод(,,)) нужно потом добавить оператор обращения к элементу массива (оператор .()).

## 6. Алгоритм.

### 6.1. Команда инициализации.

Раздел документа в разработке.

Инициализация локальной переменной.

### 6.2. Присваивание.

Раздел документа в разработке.

Присваивает переменной, стоящей слева некоторое значение, вычисляемое по формуле справа. обозначается символом "=". Множественное присваивание запрещено. При объявлении любого поля оно обязательно должно быть инициализировано.

~~~~
Поле1 = [Поле2 = [Поле3 = ... [ПолеН = ] ] ] Выражение
~~~~

??? Потом можно добавить присваивание с дополнительным действием, с тем же пироритетом, что и простое присваивание.
= *= /= %= += -= вправо= влево= би= билине= били=
справа налево
присваивание, умножение с присваиванием, деление с присваиванием, остаток от деления с присваиванием, сложение с присваиванием, вычитание с присваиванием, сдвиг вправо с присваиванием, сдвиг влево с присваиванием, побитовое И с присваиванием, побитовое исключающее ИЛИ с присваиванием, побитовое ИЛИ с присваиванием

??? Возможно надо добавить ещё больше присваивания. Например, с защищенным умножением, делением, остатком. + логическое присваивание и=, или= не=. Возможно что-то ещё, возможно лишнее и даже текущее можно сократить.

??? По идее это команда, которую надо будет описать в разделе алгоритм.

### 6.1. Условный блок.

Синтаксис условного блока:

~~~~
если [условие]:
    [тело блока]
иначе если [условие]:
    [тело блока]
...
иначе:
    [тело блока]
~~~~

Условный блок разделяется на одно или несколько подблоков. Сначала идёт обязательный подблок "если", затем могут идти подблоки "иначе если" (от 0 до бесконечности), и затем может идти подблок "иначе" (0 или 1).

Подблок "если". Сначала пишется ключевое слово "если" затем идет условие, а затем двоеточие. Условие - это выражение, которое возвращает переменную типа буль.

Подблок "иначе если" работает подобным способом. Сначала пишутся ключевые слова "иначе если" затем идет условие, а затем двоеточие. Условие - это выражение, которое возвращает переменную типа буль.

В подблоке иначе сначала пишется ключевое слово "иначе", а затем идет двоеточие.

Общая схема работы блока. Проверяется условие в блоке "если". Если условие возвращает значение "да", то выполняется тело блока и блок завершает свою работу, в противном случае поочередно проверяются условия подблоков "иначе если". Если какое-либо условие возвращает значение "да", то выполняется соответствующее ему тело подблока и блок завершает свою работу. Если ни одно условие не вернуло значение "да" и есть подблок "иначе", то выполняется тело подблока "иначе" и блок завершает работу. Если ни одно условие не вернуло значение "да" и нет подблока "иначе", то блок завершает работу.

### 6.3. Блок раскрытия неопределенности.

Синтаксис:

~~~~
раскрыть [переменная1], [переменная2], ..., [переменнаяН]:
    [тело блока]
иначе [переменная1]:
    [тело блока]
иначе [переменная2]:
    [тело блока]
...
иначе [переменнаяН]:
    [тело блока]
иначе:
    [тело блока]
~~~~

Блок пытается раскрыть переменные с неопределённостью (со знаком?). Если все переменные раскрыты (не имеют значение "Пусто"), то выполняется тело блока. В теле блока все раскрытые переменные уже имеют определённый тип. (??? вариант писать "переменная1 как раскрытая1" и в теле блока использовать уже переменную с именем "раскрытая1"). Если какая-то переменная не раскрыта, то ищется соответствующий ей блок "иначе". Если соответствующий блок не найден, то запускается блок "иначе" без переменной. Блоки "иначе" являются необязательными. Переменные пытаются раскрываться в том порядке, в котором они перечислены в объявлении блока. В блоке "иначе" все переменные которые уже были раскрыты (которые перечислены до нераскрытой переменной в объявлении) можно использовать как уже раскрытые.

Бывают попадаются нераскрытые переменные внутри других переменных. В этом случае надо писать:

~~~~
раскрыть Переменная1, Переменная1.Переменная2:
   [тело блока]
~~~~

??? Возможно лучше дать возможность сразу писать так:

~~~~
раскрыть Переменная1.Переменная2:
    [тело блока]
иначе Переменная1:
    [тело блока]
иначе Переменная1.Переменная2:
    [тело блока]
~~~~

### 6.4. Блок области видимости.

Синтаксис:

~~~~
блок:
    [тело блока]
~~~~

Принцип работы: выполняется тело блока. Единственная причина, по которой вводится такой блок - локализация области видимости переменных, объявленных внутри блока. При выходе из блока такие переменные уничтожаются.

## 7. Корневые элементы.

### 7.1. Константы и переменные.

Для константы применяется ключевое слово "конст", для перенной ключевое слово "поле". Любая константа и переменная должна быть проинициализированна. Поэтому, несмотря на строгую типизацию, тип константы и переменной записывать необязательно. Его можно однозначно вывести из правой части присвоения. Это будет либо возвращаемый тип метода или выражения, либо соответствующий литерал. Пример:

~~~~
поле а = НОД(36, 24) // Зависит от типа, который возвращает метод НОД
конст б = 3 + 5 // Тип Целое.
~~~~

Целое число объявляет переменную типа Целое, дробное число объявляет переменную типа Дробное, строка переменную типа Строка.

~~~~
    поле Количество = 34
    поле Строка = "Привет, мир!"
    поле ПримерМногострочнойПеременной = "Привет,\нмир!"
    поле ДругойМногострочный пример = "Привет
мир!"
~~~~

Ключевое слово "поле" необходимо только для провеки, что это новая переменная.

#### 7.1.1. Модификаторы поля.

Если поле является полем класса, то он имеет модификаторы

Модификаторы статичности:
* стат - статическое
* динамическое - динамическое поле (значение по-умолчанию)

Модификаторы области видимости:
* закрытое - видимо только внутри класса (значение по-умолчанию)
* защищённое - видимо внутри класса и его наследников.
* открытое - видимо всем.

#### 7.1.2. Области видимости полей.

При обнаружении в команде поля, сначала ищется обявление этого поля в текущем блоке, затем в блоке на уровень выше, и так далее до корневого блока. Потом ищется в поле текущего класса, далее родительские классы по цепочке (если есть). Далее в текущем каталоге, в текущем проекте, в библиотеках, в стандартной библиотеке.

### 7.2. Методы (функции).

Общий вид метода:

~~~~
[Модификаторы] метод [ИмяМетода] ([ВходныеДанные]) [ВыходнойТип]:
~~~~

Сначала следуют модификаторы, затем ключевое слово "метод" (??? возможно можно удалить), затем имя метода, затем в скобках перечисление входных переменных или простые скобки без входных данных, затем тип возвращаемого значения, затем ставится двоеточие.

Метод может не возвращать никаких данных. В этом случае не надо писать ВыходнойТип

#### 7.2.1. Модификаторы метода.

Модификаторы статичности:

* стат - статическая
* динамический - не статический метод (значение по-умолчанию)

Модификаторы области видимости:

* закрытый - видима только внутри класса (значение по-умолчанию)
* защищённый - видима внутри класса и его наследников.
* открытый - видима всем.

Модификаторы финализации:

* финализированный - финализированное (значение по-умолчанию)
* наследуемый - не финализирована. (Сразу же становится динамическим методом.)

Модификатор перегруженности метода:

* перегруженный - обязательный модификтор, если метод перекрывает родительский. В этом случае он также становится финализируемым по-умолчанию. Необходимо добавить в родительский метод модификатор "наследуемый", если от него будут наследоваться.

#### 7.2.2. Типы передаваемых данных.

Входные данные метод перечисляются через запятую, где сначала пишется тип переменной, а затем имя переменной:

~~~~
метод Обработать(Целое а, Строка с, Буль б) Буль:
~~~~

Передаваемые данные являются константными. То есть нельзя изменять эти переменные и поля в классе. Можно вызывать только константные методы. Константными методами называются те методы класса, которые не изменяются поля класса. Эти константные методы вычисляются компилятором (??? сложно ли это будет сделать).

(??? Возможно для не ссылочных типов разрешить модификацию внутри метода, но изменения не влияют на переменные вне метода).

~~~~
метод Сумма(Целое а, Целое б) Целое:
    вернуть а + б
~~~~

Если переменную надо изменить, то перед именем параметра метода ставится знак *. Например:

~~~~
метод Сумма(Целое *а, Целое б) Целое:
    а = а + 1
    вернуть а + б
~~~~

При вызове такого метода перед изменяемой переменной также ставится знак *. Пример:

~~~~
поле а = Сумма(*3, 5)
поле а = Сумма(*б, в)
~~~~

#### 7.2.3. Возвращаемое значение.

Возвращаемое значение может присутствовать или отсутствовать. В случае присутствия возвращаемого значения, оно имеет имя "результат", с которым можно работать в методе. (??? следить, чтобы перед работой с результатом ему должно буть присвоено значение. Сложно ли будет реализовать?)

~~~~
метод Проверить(Целое а) Буль:
    если а меньше 0:
        результат = Нет
    иначе:
        результат = Да
    вернуть результат
~~~~

## 8. Стандартная библиотека.

* В разработке.

Кар.Тип.[ЛюбойСтандартныйТип]

Кар.Время
Кар.Макрос
Кар.ГенераторСлучайныхЧисел
Кар.Поток

??? Посмотреть стандартные библиотеки C/C++, Java, C#, Python. Может ещё какие-нибудь языки.

Если(Буль условие, Тип результатДа, Тип результатНет) Тип
